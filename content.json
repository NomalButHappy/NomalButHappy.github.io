{"meta":{"title":"badEgg","subtitle":null,"description":null,"author":"badEgg","url":"https://nomalbuthappy.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"10-23","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"10-23","excerpt":""},{"title":"comment","text":"","path":"comment/index.html","date":"10-23","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"10-23","excerpt":""}],"posts":[{"title":"数据库实验 - oracle","text":"数据库实验选课的时候选了一门大型数据库，但是开学以来都没好好学习过 (当个人吧= =)，我本来以为以我原本的mysql与sqlserver的自学问题应该不大，但是oracle真是让我失策了，还有pl/sql令人头大，以下博客是自救过程中的学习与感悟 实验一 oracle安装首先是Oracle的安装，用任何搜索引擎搜索oracle然后打开download页面找到11c以后的版本下载 但是下载之前需要注册登陆一系列吧啦吧啦的操作，所以我这个小机灵鬼发现一个小办法= = 把下载按钮看一下开发者模式的链接，然后把链接复制下来用迅雷，bittorrent之类的下载器下载 我下载的是12c版本的，以下为链接 https://download.oracle.com/otn/nt/oracle12c/121020/winx64_12102_database_1of2.zip https://download.oracle.com/otn/nt/oracle12c/121020/winx64_12102_database_2of2.zip 注意两个都要下载并解压到同一个文件夹，路径不带中文 双击setup.exe进行安装，后面按照自己的需要安装即可，有无法把握的细节可以自行搜索或者在留言栏留言 使用sqlplus打开命令行控制台cmd，输入 1sqlplus system/密码 在前面的安装过程中设置的密码，若未设置默认为manager 创建一个新用户： 1create user username identified by password; 给用户授权： 1grant resource, connect to username; 连接用户： 1connect username/password *2. *根据要求建立如下表 定义基本表格major????（专业）与stud_???(学生），关系模式如下(类型长度自定义)： major_???(MajorNo专业编号 Primary key, MNAME 专业名称,loc 地址 in(主校区，南校区，新校区，铁道校区，湘雅校区),mdean 专业负责人)） stud_???(SNO primary key, SNAME, SEX (男，女，其他),TEL ,E-MAIL (基本格式判断), birthday &gt;=’19990731’ ,MNO 班长学号 FK，MajorNo 专业编号 FK ) 其中学号的第3，4位为MajorNo（专业编号）。 创建专业表代码如下 12345678create table major_J314 ( MajorNo varchar(20) primary key, MNAME varchar(20), loc varchar(20), mdean varchar(20), constraint mj_loc check (loc IN ('主校区', '南校区', '新校区', '铁道校区', '湘雅校区'))); 测试check语句是否生效 12insert into major_J314 values('02', '计算机科学与技术', '123', '张祖平'); --违反条例insert into major_J314 values('02', '计算机科学与技术', '南校区', '张祖平'); --创建成功 注意，在插入过程中如果发现对表空间 ‘USERS’ 无权限，那么在system的权限下执行语句 1alter user username quota unlimited on users 创建学生表代码如下 12345678910111213141516171819202122create table stud_J314 ( SNO varchar(20) primary key, SNAME varchar(20), SEX varchar(5), TEL varchar(20), E_MAIL varchar(20), birthday date, MNO varchar(20), MajorNo varchar(20), constraint sj_sex check (sex IN ('男','女','其他')), constraint sj_E_MAIL check (REGEXP_LIKE (E_MAIL,'[a-zA-Z0-9._%-]+@[a-zA-Z0-9._%-]+\\.[a-zA-Z]&#123;2,4&#125;')), constraint sj_birthday check (to_char(birthday, 'yyyymmdd') &gt; '1999-07-31'), constraint sj_MNO foreign key (MNO) references stud_J314(SNO), constraint sj_MajorNo foreign key (MajorNo) references major_J314(MajorNo), constraint sj_sno check (substr(SNO, 3, 2) = MajorNo)); 测试成功用例 12insert into major_J314 values('02', '计算机科学与技术', '南校区', '张祖平');insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); 这个表的创建比上面的表明显困难，因为添加了更多的约束，我把约束与测试拿出来一个个分析 SEX性别必须是’男’,’女’,’其他’中的一个，这个我们在上一个表中已经实现 12insert into stud_J314 values ('0902170314', '颜灿', '1', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); --违反检查约束条件SJ_SEXinsert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); --已创建一行 E_MAIL需要约束成XXX@XXX.XXX的格式，为了更加精确，我用了oracle允许的正则表达式[a-zA-Z0-9.%-]+@[a-zA-Z0-9.%-]+.[a-zA-Z]{2,4}来对格式进行规范 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); --违反检查约束条件SJ_E_MAIL MNO与MajorNo需要添加外键，MajorNo直接与之前的Major表关联成为外键，但是MNO我思来想去还是觉得他应该成为自己的表的主键的外键。 注意 当MajorNo与自己的主键关联时，也就是说插入班级的每个数据之前必须先插入班长的数据！！！否则就会出现外键找不到父项关键字的报错！！！ 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170313', '02'); --未找到父项关键字 然后就是生日的约束，这里需要用到 date 的数据类型，以及char与date之间的转化to_char(birthday, ‘yyyymmdd’)，to_date(birthday, ‘YYYYMMDD’)。 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('19981010', 'YYYYMMDD'), '0902170314', '02'); --违反检查约束条件SJ_BIRTHDAY 学号的第3，4位为MajorNo，所以我们需要截断字符串，需要用到方法substr(字符串, 第几个字符, 截取几个字符) 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '03'); --违反检查约束条件SJ_SNO 插入样本数据插入3个专业，如计算机科学与技术，物联网工程，数据科学与大数据技术，每个专业不少于10个人，其中包括自己的信息。 测试相关的完整性约束，并注意保留出错的提示，分析出错的原因。 根据上面分析的约束，我们需要先插入没有外键的表 major_U314 12 补充sqlplus允许把sql语句写在txt或sql文件中，使用 1SQL&gt; @绝对地址就可以访问并运行 实验二","path":"2019/10/23/数据库实验/","date":"10-23","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://nomalbuthappy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"leetcode - 整数反转","text":"leetcode: 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-integer 首先，反转整数需要考虑两点，一是是否有负号，有符号需要把符号放到最前面，二是末尾有没有0，有0需要去掉，因为数字首位是不能为零的。 考虑到python取模10时结果会是正数，所以把数字转为字符处理更为方便 另外，题设假设环境只能存储得下32位int整型数字，python不需要考虑数字长度，所以我们直接用if判断数字大小 代码如下： 12345678910111213class Solution: def reverse(self, x: int) -&gt; int: if x == 0: return 0 str_x = str(x) x = '' if str_x[0] == '-': x += '-' x += str_x[len(str_x)-1::-1].lstrip(\"0\").rstrip(\"-\") x = int(x) if -2**31&lt;x&lt;2**31-1: return x return 0 注意到其中用了[len(str_x)-1::-1]，意义是从len(str_x)开始，以-1递减的方式截取，达到反取的作用，第二位不写默认是0 lstrip方法，表示截取最左边的某个字符，多个重复全部截取 rstrip方法同上不过是截取右边 评论大佬中也有不处理为字符串的方法，就是对数字做取余处理，这里贴一下代码以供学习： 123456789101112131415161718192021222324class Solution: def reverse(self, x: int) -&gt; int: # 避免python负数取模的特性，改为对正数取整 num: int = x if x &gt; 0 else -x ans: int = 0 MAX_VALUE = 2147483647 MIN_VALUE = -2147483648 while(num != 0): pop: int = num % 10 if x &gt; 0: if (ans &gt; MAX_VALUE // 10) or (ans == MAX_VALUE // 10 and pop &gt; 7): # 正溢出 return 0 elif x &lt; 0: if (ans &gt; -MIN_VALUE // 10) or (ans == -MAX_VALUE // 10 and pop &gt; 8): # 负溢出 return 0 ans = ans * 10 + pop num //= 10 return ans if x &gt; 0 else -ans 想起樱木花道的经典台词：安西教练，你最光荣的时候是什么时候，是在日本国家队的时候吗？而我，只有现在了！ 菜鸟坚持一天至少一篇，先从简单起，慢慢来吧。","path":"2019/10/23/leetcode-整数反转/","date":"10-23","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 两数之和","text":"leetcode: 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 对这道题一开始的思路是两套循环遍历找到为目标值的两个数，代码如下: 123456class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if(nums[i] + nums[j] == target): return [i, j] 循环遍历一遍，时间复杂度是n^2，可以通过但是非常常规且有时会超时 经过评论大佬的启迪，做一次排序后首尾递进显然更快，复杂度为排序的nlogn 12345678910111213class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: sorted_id = sorted(range(len(nums)), key=lambda k: nums[k]) head = 0 tail = len(nums) - 1 sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]] while sum_result != target: if sum_result &gt; target: tail -= 1 elif sum_result &lt; target: head += 1 sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]] return [sorted_id[head], sorted_id[tail]] 这个速度明显会更快，但更花费空间 这样还不够，发现比较的都是数字，那么就有了更快的办法—hash字典 123456789class Solution: def twoSum(self, nums, target): hashmap = &#123;&#125; for index, num in enumerate(nums): another_num = target - num if another_num in hashmap: return [hashmap[another_num], index] hashmap[num] = index return None 用hash字典大大增加了内存但是速度快到了n 还是图样图森破 这是第一天份的，明天继续= =","path":"2019/10/23/leetcode两数之和/","date":"10-23","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 回文数","text":"leetcode: 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 这一题和整数反转很像，都需要给数做一个反转，但是从转为字符串的角度来看，反而更加简单了 代码如下： 12345678class Solution: def isPalindrome(self, x: int) -&gt; bool: str_x = str(x) x = '' if str_x[len(str_x) - 1::-1] == str_x: return True else: return False 进阶任务：如何在不转为字符串的前提下解决这个问题 在不转为字符串的前提下，我们只要用数字的方法计算出反转后的数字大小进行比较就可以达到目的 代码如下： 1234567891011121314class Solution: def isPalindrome(self, x: int) -&gt; bool: if x &lt; 0 : return False m,n = x,0 while m: n = n*10 + m%10 m = m//10 if x == n: return True else: return False 今天的比较简单，留空看看大型数据库吧= = 我能够允许你逃避过去，不过至少从现在或者明天开始都不要再逃避。 -「无头骑士异闻录」","path":"2019/10/23/leetcode-回文数/","date":"10-23","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"212 23事","text":"212 23事这篇博客的内容来自博主波澜不惊的日常，记下来当作回忆 为了保护个人隐私，以下人名全部由字母w，y，z，h代替 该博客将不定期更新，全凭心情 1.dai作家z: 我说啊，不是有一种学习方法叫渗透压学习法吗？ y: 是啊，就是那个睡觉的时候把书放在枕头下，然后由于书里的知识渗透压比大脑大，会不断渗入大脑嘛 z: 对啊，但是你不感觉奇怪吗？这个效应应该发生在液体之间，而书和大脑都是固体，怎么发生这个作用？ y: 分子的无规则运动也可以发生在固体和固体之间啊，像那个金块和铅块 h: 你还没考虑知识可能会沉降，那就是说你脑袋里的知识可能会往书里走 z: 那我早上一觉起来不是发现书的页数变多了？？？ y: 那你不就成了作者了，从你的知识储备来看，会是嘎啦game CG集= = z: 沉啦，那我也是dai作家啦 2. 杀室友晚上放学的时候 h: 今天晚上一定要早睡！ y: 不可能的，每天都这么说，你看哪天早睡了？ h: 如果我超过1点，每晚睡10分钟 y: ？？？ h: 我就杀一个室友 y: = =||| h: = = y: ？？？？？？！！！！！！ 在一顿操作猛如虎以后，凌晨四点半了 y: h，你还记得晚上说过什么吗？ h: = = z: 他说了什么啊 y: 他说每超过一点钟10分钟睡觉 h: 我就杀一个室友 z: 你也太狠了嗷~~ y: 不如随机杀一个，另外两个直接保研 h: 那就杀你吧 y: 不太行，我得套复活甲 z: 现在四点半，算起来要杀21个室友，一个复活甲不太行 y: 现在我们有三个人，每个人把装备栏套满，那就是18条命，艹 z: h，我们可不可以等个复活甲冷却 h: zzzzZZZZ y: = = z: = = w: = = 3. 谁的锅w在看斗罗大陆动画 w: 我发现宁荣荣的那个比柳二龙的还要大 y: 那不就是建模的锅咯 z: 嗯？升调 剑魔又背锅咯？怎么不是剑圣的锅啦 y: ？？？ w: 行吧，那就是剑圣的锅 h: 好，决定了，就是剑姬的锅","path":"2019/10/01/212-23事/","date":"10-01","excerpt":"","tags":[{"name":"日常","slug":"日常","permalink":"https://nomalbuthappy.github.io/tags/%E6%97%A5%E5%B8%B8/"}]}]}