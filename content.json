{"meta":{"title":"badEgg","subtitle":null,"description":null,"author":"badEgg","url":"https://nomalbuthappy.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"10-23","excerpt":""},{"title":"about","text":"关于我新的博客，新的开始。 这次绝对不鸽！ 真的？ 应该吧….. 标签：咸鱼，翻不了身的那种，代码控，手办控，妹控，魔法师（初级火球术）","path":"about/index.html","date":"10-23","excerpt":""},{"title":"comment","text":"有什么想说的就留在这里吧:-)","path":"comment/index.html","date":"10-23","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"10-23","excerpt":""}],"posts":[{"title":"leetcode - 两数相加","text":"leetcode: 两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-two-numbers 这题是一道中等难度的题（可怜我这个彩笔前几天只敢做简单题），这题设计的一个关键就是链表 首先，链表中的两数相加应该是和加法一样各个位相加，而各个位相加的话就会有一个进位的问题，这题的关键就是处理这个进位的问题 代码如下： 12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" re = ListNode(0) //初始化一个链表节点，作为头节点 r = re //作为建立链表的节点 carry = 0 while(l1 or l2): x = l1.val if l1 else 0 y = l2.val if l2 else 0 s = carry + x + y carry = s // 10 r.next = ListNode(s % 10) r = r.next if (l1 != None): l1 = l1.next if (l2 != None): l2 = l2.next if (carry &gt; 0): r.next = ListNode(1) return re.next 其中有一个语法 1x = l1.val if l1 else 0 意思同 1234if l1: x = l1.valelse: x = 0 实际上这个还有一个优化的空间，就是在发现了l1 或 l2为空的时候让 r 指向非空的链，节约算法空间与时间 上面的方法确实可行，在一条链结束的时候若有进位，而后面又全都是9，那就需要一个循环，这样可以提高一定的效率，下次二刷的时候再实现吧 LPL联手出现保送决赛= =，但是skt是最强的: - )","path":"2019/10/27/leetcode-两数相加/","date":"10-27","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"自搭hexo博客","text":"自搭hexo博客教程hexo是一个可以轻量方便依托于githubpage的博客，原本我是自搭博客，从前端到后台全包干，但是这样不仅自己设计上面存在问题需要不断，修改越改心越累，也没办法把全部精力留在博客质量上，所以我还是选择了hexo，还省了一个服务器，美滋滋= = 注 以下教程的操作系统是window，linux请寻找其他相应教程或等待后续教程 准备工作 注册一个github账号 操作系统安装node.js。这个可以搜索官网免费下载安装后用 12node -vnpm -v 检查是否安装成功 安装git，同样是搜索官网下载安装好后，用 1git --version 检查一下环境 下载3.x以后版本的hexo 先创建一个文件夹用于保存hexo，然后右键gitbash，输入 12345npm install hexo-cli -g //等待进度条读完后就下载完成了hexo init myblog //初始化一个myblog，也可以是其他名字cd myblog //进入myblog文件夹hexo g //生成博客hexo server //生成预览 默认localhost:4000可以浏览 创建仓库新建一个仓库，在右上角的加号new repository，创建一个和用户名相同的仓库，后加.github.io 只有这样在部署githubpage的时候才会被识别，所以从这个角度来说一个用户只能有一个github提供的域名 生成SSH并添加到github回到git bash中 12345git config --global user.name &quot;yourname&quot; //存入你的github用户名git config --global user.email &quot;youremail&quot; //存入你注册时用的邮箱git config user.name //检查一遍你的输入git config user.email //同上ssh-keygen -t rsa -C &quot;youremail&quot; //生成SSH，在电脑里找到它，返回有提示位置 其中，我们要用的是公钥公开给github，就是哪个id_rsa.pub，复制里面的内容，在右上角用户找到setting，点击找到SSH keys新建一个把id_rsa.pub复制进去，再回到gitbash 1ssh -T git@github.com //返回success就是部署成功 配置博客打开myblog中的_config.yml配置文件，找到deploy，修改为 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 再回到gitbash 1234npm install hexo-deployer-git --save //安装deploy-git用于推送到github上hexo clean //用于清理之前生成的文件hexo g //generate的缩写，生成博客hexo d //deploy的缩写，部署到github 过一会儿，你就可以在http://yourname.github.io上看到你的博客了，他现在还很简单，没有内容没有主题 内容在source/_post中添加 主题可以直接找，每个主题的要求不同配置方法也不同所以基本上都有配置文档或教程 以上 ps 有点没写好，很多瑕疵 ma，算了，反正没有人看= = 有点冷啊，咸鱼落泪 : - )","path":"2019/10/25/自搭hexo博客/","date":"10-25","excerpt":"","tags":[]},{"title":"leetcode - 最长公共前缀","text":"leetcode: 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot; 首先，这一题的思路是从头到尾两辆比较，上一次比较的公共前缀用于下一次比较，代码如下： 123456789101112131415161718192021222324class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" if strs == []: return \"\" else: s = strs[0] for i in range(1, len(strs)): temp = \"\" if strs[i] == \"\": return \"\" else: for j in range(min(len(strs[i]), len(s))): if(strs[i][j] == s[j]): temp += s[j] if j == min(len(strs[i]), len(s)) - 1: s = temp else: s = temp; break; return s 可以看到，这个方法我们用了很多的特殊情况处理，比如只有空list，list中有空串等（一次次出错中补出来的= =） 评论中有一些启发的思路，比如说，字符串是可以比较大小的，那么不就可以直接只比较最大和最小的两项吗 代码如下 123456789101112131415161718class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" temp = \"\" if strs == []: //也能写成if not strs return \"\" else: smax = max(strs) smin = min(strs) for i in range(min(len(smax), len(smin))): if smax[i] == smin[i]: temp += smax[i] else: break return temp 另外就是利用zip函数，把str对齐压缩然后去重，取最短的对象的函数特性正好可以利用到，在list中找到长度大于1前的就是公共前缀，有点神奇： 1234567891011class Solution(object): def longestCommonPrefix(self, strs): if not strs: return \"\" ss = list(map(set, zip(*strs))) res = \"\" for i, x in enumerate(ss): x = list(x) if len(x) &gt; 1: break res = res + x[0] return res 这是今天的份了。 今天雨有点大，鞋也湿了，头有点痛晚上还有实验。。。 心塞的看看桌上的老婆，发现双十一买不起新老婆 呵，男人","path":"2019/10/25/leetcode-最长公共前缀/","date":"10-25","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 罗马数字转整数","text":"leetcode: 罗马数字转整数例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 罗马数字转整数乍一看觉得需要多方面的考虑比如每个字符之间的组合分别考虑之类的，但是再细看我们可以发现，实际上我们做计算时它遵循的只有两个规律 左边大于右边时加上这个左边的数 左边小于右边时减去这个左边的数 那么我们就可以着手编程了: 12345678910class Solution(object): def romanToInt(self, s): d = &#123;'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000&#125; ans=0 for i in range(len(s)): if i&lt;len(s)-1 and a[s[i]]&lt;a[s[i+1]]: ans-=a[s[i]] else: ans+=a[s[i]] return ans 膜拜大佬，有个两行就解决的大佬，分析一下他的解法 123456class Solution: def romanToInt(self, s: str) -&gt; int: d = &#123;'I':1, 'IV':3, 'V':5, 'IX':8, 'X':10, 'XL':30, 'L':50, 'XC':80, 'C':100, 'CD':300, 'D':500, 'CM':800, 'M':1000&#125; return sum(d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s)) 链接：https://leetcode-cn.com/problems/roman-to-integer/solution/2-xing-python-on-by-knifezhu/ 首先用map把各个字符的数字列出来，不过大佬与众不同的是这里用了遍历的方法，就是上面我说的每个字母之间的组合分别考虑全部列出 比如，IV为4，先读I为1，再读V，IV为3，加起来就是4达到了IV是4的效果再从头到尾遍历一边就可以解决问题 今日份完工！ 话说不知道是脑抽还是什么买了一桶比我手臂还粗的饼干，真好，能吃一年了: - )","path":"2019/10/24/leetcode-罗马数字转整数/","date":"10-24","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"数据库实验 - oracle","text":"数据库实验选课的时候选了一门大型数据库，但是开学以来都没好好学习过 (当个人吧= =)，我本来以为以我原本的mysql与sqlserver的基础问题应该不大，但是oracle真是让我失策了，还有pl/sql令人头大，以下博客是自救过程中的学习与感悟 实验一 oracle安装首先是Oracle的安装，用任何搜索引擎搜索oracle然后打开download页面找到11c以后的版本下载 但是下载之前需要注册登陆一系列吧啦吧啦的操作，所以我这个小机灵鬼发现一个小办法= = 把下载按钮看一下开发者模式的链接，然后把链接复制下来用迅雷，bittorrent之类的下载器下载 12c版本的，以下为链接 https://download.oracle.com/otn/nt/oracle12c/121020/winx64_12102_database_1of2.zip https://download.oracle.com/otn/nt/oracle12c/121020/winx64_12102_database_2of2.zip 注意两个都要下载并解压到同一个文件夹，路径不带中文 双击setup.exe进行安装，后面按照自己的需要安装即可，有无法把握的细节可以自行搜索或者在留言栏留言 使用sqlplus打开命令行控制台cmd，输入 1sqlplus system/密码 在前面的安装过程中设置的密码，若未设置默认为manager 创建一个新用户： 1create user username identified by password; 给用户授权： 1grant resource, connect to username; 连接用户： 1connect username/password *2. *根据要求建立如下表 定义基本表格major????（专业）与stud_???(学生），关系模式如下(类型长度自定义)： major_???(MajorNo专业编号 Primary key, MNAME 专业名称,loc 地址 in(主校区，南校区，新校区，铁道校区，湘雅校区),mdean 专业负责人)） stud_???(SNO primary key, SNAME, SEX (男，女，其他),TEL ,E-MAIL (基本格式判断), birthday &gt;=’19990731’ ,MNO 班长学号 FK，MajorNo 专业编号 FK ) 其中学号的第3，4位为MajorNo（专业编号）。 创建专业表代码如下 12345678create table major_J314 ( MajorNo char(20) primary key, MNAME varchar(50), loc varchar(20), mdean varchar(20), constraint mj_loc check (loc IN ('主校区', '南校区', '新校区', '铁道校区', '湘雅校区'))); 测试check语句是否生效 12insert into major_J314 values('02', '计算机科学与技术', '123', '张祖平'); --违反条例insert into major_J314 values('02', '计算机科学与技术', '南校区', '张祖平'); --创建成功 注意，在插入过程中如果发现对表空间 ‘USERS’ 无权限，那么在system的权限下执行语句 1alter user username quota unlimited on users 创建学生表代码如下 12345678910111213141516171819202122create table stud_J314 ( SNO varchar(20) primary key, SNAME varchar(20), SEX varchar(5), TEL varchar(20), E_MAIL varchar(20), birthday date, MNO char(20), MajorNo char(20), constraint sj_sex check (sex IN ('男','女','其他')), constraint sj_E_MAIL check (REGEXP_LIKE (E_MAIL,'[a-zA-Z0-9._%-]+@[a-zA-Z0-9._%-]+\\.[a-zA-Z]&#123;2,4&#125;')), constraint sj_birthday check (to_char(birthday, 'yyyymmdd') &gt; '1999-07-31'), constraint sj_MNO foreign key (MNO) references stud_J314(SNO), constraint sj_MajorNo foreign key (MajorNo) references major_J314(MajorNo), constraint sj_sno check (substr(SNO, 3, 2) = MajorNo)); 测试成功用例 12insert into major_J314 values('02', '计算机科学与技术', '南校区', '张祖平');insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); 这个表的创建比上面的表明显困难，因为添加了更多的约束，我把约束与测试拿出来一个个分析 SEX性别必须是’男’,’女’,’其他’中的一个，这个我们在上一个表中已经实现 12insert into stud_J314 values ('0902170314', '颜灿', '1', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); --违反检查约束条件SJ_SEXinsert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); --已创建一行 E_MAIL需要约束成XXX@XXX.XXX的格式，为了更加精确，我用了oracle允许的正则表达式[a-zA-Z0-9.%-]+@[a-zA-Z0-9.%-]+.[a-zA-Z]{2,4}来对格式进行规范 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); --违反检查约束条件SJ_E_MAIL MNO与MajorNo需要添加外键，MajorNo直接与之前的Major表关联成为外键，但是MNO我思来想去还是觉得他应该成为自己的表的主键的外键。 注意 当MajorNo与自己的主键关联时，也就是说插入班级的每个数据之前必须先插入班长的数据！！！否则就会出现外键找不到父项关键字的报错！！！ 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170313', '02'); --未找到父项关键字 然后就是生日的约束，这里需要用到 date 的数据类型，以及char与date之间的转化to_char(birthday, ‘yyyymmdd’)，to_date(birthday, ‘YYYYMMDD’)。 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('19981010', 'YYYYMMDD'), '0902170314', '02'); --违反检查约束条件SJ_BIRTHDAY 学号的第3，4位为MajorNo，所以我们需要截断字符串，需要用到方法substr(字符串, 第几个字符, 截取几个字符) 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '03'); --违反检查约束条件SJ_SNO 插入样本数据插入3个专业，如计算机科学与技术，物联网工程，数据科学与大数据技术，每个专业不少于10个人，其中包括自己的信息。 测试相关的完整性约束，并注意保留出错的提示，分析出错的原因。 根据上面分析的约束，我们需要先插入没有外键的表 major_U314 123insert into major_J314 values('02', '计算机科学与技术', '南校区', '张祖平');insert into major_J314 values('03', '物联网工程', '南校区', '张祖平');insert into major_J314 values('04', '数据科学与大数据技术', '南校区', '张祖平'); 下一个插入的就是学生表，但是注意了，学生表中由于约束到的是自己的主键，需要先插入班长的信息 1234567891011121314151617181920212223242526272829303132333435--班长学生insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0903170314', 'a', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '03');insert into stud_J314 values ('0904170314', 'b', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');--非班长学生insert into stud_J314 values ('0902170101', '1', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170102', '2', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170103', '3', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170104', '4', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170105', '5', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170106', '6', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170107', '7', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170108', '8', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170109', '9', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0903170101', '1', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170102', '2', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170103', '3', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170104', '4', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170105', '5', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170106', '6', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170107', '7', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170108', '8', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170109', '9', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0904170101', '1', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170102', '2', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170103', '3', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170104', '4', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170105', '5', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170106', '6', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170107', '7', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170108', '8', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170109', '9', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');--其他以此类推 实现权限控制为每个学生建立相关用户，实现权限控制，每个学生可查询自己的信息，班长可查询本班所有学生信息；为每个专业负责人建立用户，每个专业负责人可查询本专业所有学生信息。 首先我要先把用户建立好 1234567select MajorNo from major_J314;select MNAME from major_J314; //以上两行用来看= =select 'create user u'||MajorNo||' identified by p'||MajorNo||';' from major_J314;select 'drop user u'||MajorNo||';' from major_J314; //删除用户，这里是写了备用select SNO from stud_J314;select 'create user u'||SNO||' identified by p'||SNO||';' from stud_J314;select 'drop user u'||SNO||';' from stud_J314; //删除用户，这里是写了备用 划重点 这里的select ‘’语句只有选择出所有合适语句的作用而不会运行那么，我们就要先把语句选出来存起来再全部运行 先建立一个txt或sql文件，写入 1234567891011121314151617clear screenconn U_J314/YcYyj1234 连接用户名与密码spool offset heading offset echo offset feedback offspool d:\\blog\\user.txt选出后存储的地址文件，可以用txt---选择语句，注意，只有选择语句会留下记录---spool offset heading onset echo onset feedback onspool d:\\blog\\demo.txt运行过程的记录，同样用令一个文件记录@d:\\blog\\user.txt 运行user的内容spool off 但是，在我实际创建的过程中发现一个问题 — 权限不足= = 创建用户就需要系统管理员的权限了 1grant dba to U_J314(这里用自己的用户名); 下一步是每个人的权限 12select 'grant connect to u'||MajorNo||';' from major_J314;select 'grant connect to u'||SNO||';' from stud_J314; 建立一个视图并给予视图的权限 123456create view V_J314 as select * from stud_J314 where 'u'||SNO=user or 'u'||MNO=user or 'u'||majorNo=user;grant select on V_J314 to public;--测试数据select * from U_J314.V_J314 心态崩了，真就没办法过啊 补充之前和个沙雕一样，想一想不如每个人建立一个视图 代码如下 12345678select 'drop view V_'||SNO||';' from stud_J314;select 'create view V_'||SNO||' as select * from stud_J314 where SNO = '||SNO||' or MNO = '||SNO||';' from stud_J314;select 'grant select on V_'||SNO||' to u'||SNO||';' from stud_J314;select 'drop view V_'||MajorNo||';' from major_J314;select 'create view V_'||MajorNo||' as select * from stud_J314 where MajorNo='||MajorNo||';' from major_J314;select 'grant select on V_'||MajorNo||' to u'||MajorNo||';' from major_J314;测试数据select * from U_J314.V_(学号或年级号) 测试通过，任务完成: - ) 实验二","path":"2019/10/23/数据库实验/","date":"10-23","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://nomalbuthappy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"leetcode - 整数反转","text":"leetcode: 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-integer 首先，反转整数需要考虑两点，一是是否有负号，有符号需要把符号放到最前面，二是末尾有没有0，有0需要去掉，因为数字首位是不能为零的。 考虑到python取模10时结果会是正数，所以把数字转为字符处理更为方便 另外，题设假设环境只能存储得下32位int整型数字，python不需要考虑数字长度，所以我们直接用if判断数字大小 代码如下： 12345678910111213class Solution: def reverse(self, x: int) -&gt; int: if x == 0: return 0 str_x = str(x) x = '' if str_x[0] == '-': x += '-' x += str_x[len(str_x)-1::-1].lstrip(\"0\").rstrip(\"-\") x = int(x) if -2**31&lt;x&lt;2**31-1: return x return 0 注意到其中用了[len(str_x)-1::-1]，意义是从len(str_x)开始，以-1递减的方式截取，达到反取的作用，第二位不写默认是0 lstrip方法，表示截取最左边的某个字符，多个重复全部截取 rstrip方法同上不过是截取右边 评论大佬中也有不处理为字符串的方法，就是对数字做取余处理，这里贴一下代码以供学习： 123456789101112131415161718192021222324class Solution: def reverse(self, x: int) -&gt; int: # 避免python负数取模的特性，改为对正数取整 num: int = x if x &gt; 0 else -x ans: int = 0 MAX_VALUE = 2147483647 MIN_VALUE = -2147483648 while(num != 0): pop: int = num % 10 if x &gt; 0: if (ans &gt; MAX_VALUE // 10) or (ans == MAX_VALUE // 10 and pop &gt; 7): # 正溢出 return 0 elif x &lt; 0: if (ans &gt; -MIN_VALUE // 10) or (ans == -MAX_VALUE // 10 and pop &gt; 8): # 负溢出 return 0 ans = ans * 10 + pop num //= 10 return ans if x &gt; 0 else -ans 想起樱木花道的经典台词：安西教练，你最光荣的时候是什么时候，是在日本国家队的时候吗？而我，只有现在了！ 菜鸟坚持一天至少一篇，先从简单起，慢慢来吧。","path":"2019/10/23/leetcode-整数反转/","date":"10-23","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 两数之和","text":"leetcode: 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 对这道题一开始的思路是两套循环遍历找到为目标值的两个数，代码如下: 123456class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if(nums[i] + nums[j] == target): return [i, j] 循环遍历一遍，时间复杂度是n^2，可以通过但是非常常规且有时会超时 经过评论大佬的启迪，做一次排序后首尾递进显然更快，复杂度为排序的nlogn 12345678910111213class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: sorted_id = sorted(range(len(nums)), key=lambda k: nums[k]) head = 0 tail = len(nums) - 1 sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]] while sum_result != target: if sum_result &gt; target: tail -= 1 elif sum_result &lt; target: head += 1 sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]] return [sorted_id[head], sorted_id[tail]] 这个速度明显会更快，但更花费空间 这样还不够，发现比较的都是数字，那么就有了更快的办法—hash字典 123456789class Solution: def twoSum(self, nums, target): hashmap = &#123;&#125; for index, num in enumerate(nums): another_num = target - num if another_num in hashmap: return [hashmap[another_num], index] hashmap[num] = index return None 用hash字典大大增加了内存但是速度快到了n 还是图样图森破 这是第一天份的，明天继续= =","path":"2019/10/23/leetcode两数之和/","date":"10-23","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 回文数","text":"leetcode: 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 这一题和整数反转很像，都需要给数做一个反转，但是从转为字符串的角度来看，反而更加简单了 代码如下： 12345678class Solution: def isPalindrome(self, x: int) -&gt; bool: str_x = str(x) x = '' if str_x[len(str_x) - 1::-1] == str_x: return True else: return False 进阶任务：如何在不转为字符串的前提下解决这个问题 在不转为字符串的前提下，我们只要用数字的方法计算出反转后的数字大小进行比较就可以达到目的 代码如下： 1234567891011121314class Solution: def isPalindrome(self, x: int) -&gt; bool: if x &lt; 0 : return False m,n = x,0 while m: n = n*10 + m%10 m = m//10 if x == n: return True else: return False 今天的比较简单，留空看看大型数据库吧= = 我能够允许你逃避过去，不过至少从现在或者明天开始都不要再逃避。 -「无头骑士异闻录」","path":"2019/10/23/leetcode-回文数/","date":"10-23","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"212 23事","text":"212 23事这篇博客的内容来自博主波澜不惊的日常，记下来当作回忆 为了保护个人隐私，以下人名全部由字母w，y，z，h代替 该博客将不定期更新，全凭心情 1.dai作家z: 我说啊，不是有一种学习方法叫渗透压学习法吗？ y: 是啊，就是那个睡觉的时候把书放在枕头下，然后由于书里的知识渗透压比大脑大，会不断渗入大脑嘛 z: 对啊，但是你不感觉奇怪吗？这个效应应该发生在液体之间，而书和大脑都是固体，怎么发生这个作用？ y: 分子的无规则运动也可以发生在固体和固体之间啊，像那个金块和铅块 h: 你还没考虑知识可能会沉降，那就是说你脑袋里的知识可能会往书里走 z: 那我早上一觉起来不是发现书的页数变多了？？？ y: 那你不就成了作者了，从你的知识储备来看，会是嘎啦game CG集= = z: 沉啦，那我也是dai作家啦 2. 杀室友晚上放学的时候 h: 今天晚上一定要早睡！ y: 不可能的，每天都这么说，你看哪天早睡了？ h: 如果我超过1点，每晚睡10分钟 y: ？？？ h: 我就杀一个室友 y: = =||| h: = = y: ？？？？？？！！！！！！ 在一顿操作猛如虎以后，凌晨四点半了 y: h，你还记得晚上说过什么吗？ h: = = z: 他说了什么啊 y: 他说每超过一点钟10分钟睡觉 h: 我就杀一个室友 z: 你也太狠了嗷~~ y: 不如随机杀一个，另外两个直接保研 h: 那就杀你吧 y: 不太行，我得套复活甲 z: 现在四点半，算起来要杀21个室友，一个复活甲不太行 y: 现在我们有三个人，每个人把装备栏套满，那就是18条命，艹 z: h，我们可不可以等个复活甲冷却 h: zzzzZZZZ y: = = z: = = w: = = 3. 谁的锅w在看斗罗大陆动画 w: 我发现宁荣荣的那个比柳二龙的还要大 y: 那不就是建模的锅咯 z: 嗯？升调 剑魔又背锅咯？怎么不是剑圣的锅啦 y: ？？？ w: 行吧，那就是剑圣的锅 h: 好，决定了，就是剑姬的锅","path":"2019/10/01/212-23事/","date":"10-01","excerpt":"","tags":[{"name":"日常","slug":"日常","permalink":"https://nomalbuthappy.github.io/tags/%E6%97%A5%E5%B8%B8/"}]}]}