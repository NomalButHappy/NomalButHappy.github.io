{"meta":{"title":"badEgg","subtitle":null,"description":null,"author":"badEgg","url":"https://nomalbuthappy.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"10-23","excerpt":""},{"title":"about","text":"关于我新的博客，新的开始。 这次绝对不鸽！ 真的？ 应该吧….. 标签：咸鱼，翻不了身的那种，代码控，手办控，妹控，魔法师（初级火球术）","path":"about/index.html","date":"10-23","excerpt":""},{"title":"comment","text":"有什么想说的就留在这里吧:-)","path":"comment/index.html","date":"10-23","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"10-23","excerpt":""}],"posts":[{"title":"leetcode - 括号生成","text":"leetcode: 括号生成给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 这一题是从一道简单题推过来的，那道题是这样，判断一个括号串是否有效，当时用的是栈的知识，那么这一题的区别就在找到括号生成的规律，现在我们可以分析一下它的规律了 首先长度肯定是两倍给出的n 左括号与右括号相等 在任何位置左括号数都要大于等于右括号 好的，那么为了列出这所有的可能，我们需要用到回溯法 1234567891011121314class Solution(object): def generateParenthesis(self, N): ans = [] def backtrack(S = '', left = 0, right = 0): if len(S) == 2 * N: ans.append(S) return if left &lt; N: backtrack(S+'(', left+1, right) if right &lt; left: backtrack(S+')', left, right+1) backtrack() return ans 回溯法是指比如走迷宫有很多路，我们需要一个一个路的探，通了就是一个结果，为了实现这个算法思想，我们一般用递归的思路来完成他。 好的，又是一条咸鱼，不过本欧皇昨天抽奖抽到一个异色初音，可以来一期开箱博客= =。","path":"2019/11/22/leetcode - 括号生成/","date":"11-22","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 报数","text":"leetcode: 报数报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 123451. 12. 113. 214. 12115. 111221 1 被读作 “one 1” (“一个一”) , 即 11。11 被读作 “two 1s” (“两个一”）, 即 21。21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 这一题看起来有点迷。主要是做一个循环不断让下一个表示上一段的数字 好的，既然是简单的循环，我们就来看看代码 12345678910111213141516171819202122class Solution(object): def countAndSay(self, n): \"\"\" :type n: int :rtype: str \"\"\" s = \"1\" for i in range(2, n+1): count = 0 a = s[0] temp = \"\" for j in s: if a == j: count += 1 else: temp += str(count) + a count = 1 a = j temp += str(count) + a s = temp return s 中规中矩，循环通过，时间复杂度为一个n^2 ? 这个复杂度可能不止，但是有一个我万万没想到的方法就是看到了n的范围，那么把从1 到 30都列一遍时间复杂度就是 1 ！！！？？？ 虽然没必要但是确实很屌= = 今天也是一条咸鱼呢，快乐咸鱼每一天！","path":"2019/11/21/leetcode - 报数/","date":"11-21","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 搜索插入位置","text":"leetcode: 搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 好的，简单题终结者石锤了= =|| 这题就是一遍遍历过去就完事了 1234567891011121314class Solution(object): def searchInsert(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" for i in range(len(nums)): if nums[i] == target: return i elif nums[i] &gt; target: return i return len(nums) 我不想咸鱼啊，可是大脑他不允许啊艹！明天又大一岁了，还是努点力吧 : - ( 【在，为什么咸鱼！】 【因为懒啊！】","path":"2019/11/16/leetcode - 搜索插入位置/","date":"11-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 盛最多水的容器","text":"leetcode: 盛最多水的容器给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 示例: 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 这一题我在草稿纸上比比划划好久才搞清楚逻辑，首先，乍一看n个非负整数里面找到最大面积需要暴力遍历一遍，但是遍历是最没办法的办法–它极有可能超时，所以我们需要找到它的规律 对于面积的计算应该是底的长度和最短的高的乘积 然后如何找到这两条边就是我们的关键了，我们需要两个边，所以我们最好从左右两边最远的位置开始找，不断找到更大值才是题目关键，从短的一边开始找，因为高的一边无论怎么找计算的边都是短边，那么面积只会更小，所以我们不断从找更高的边并更新最大面积值，这就是这一题的灵魂所在了 捋清楚了我们就上代码 1234567891011121314151617181920class Solution(object): def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" cleft = 0 cright = len(height) - 1 s = min(height[cleft], height[cright]) * (cright - cleft) ss = 0 while cright &gt; cleft: if height[cleft] &gt; height[cright]: cright -= 1 else: cleft += 1 ss = min(height[cleft], height[cright]) * (cright - cleft) if s &lt; ss: s = ss return s 也许会有人疑惑是否在这样的遍历中会错过最大值，我们可以分析一下,我们还是看看大佬的比我分析得好多了 https://leetcode-cn.com/problems/container-with-most-water/solution/shuang-zhi-zhen-fa-zheng-que-xing-zheng-ming-by-r3/ 另外，实际上在左右两边相等时应该还要有一点考量，但是既然过了那就算了= = 今天开始锻炼身体，可能，这就是淬体吧= =","path":"2019/11/12/leetcode-盛最多水的容器/","date":"11-12","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 字符串转换整数 (atoi)","text":"leetcode: 字符串转换整数 (atoi)请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 这一题是需要实现一个函数，函数内容就是把字符串转为整数，在c/c++中有一个atoi的函数就是这个功能（to int），那么我们来分析一下这一题的方法 首先，需要丢弃无用开头空格，我们可以用之前提到过的strip来去头去尾的空格 然后第一个字符可能是正负号，后面是连续的数字，这一部分就需要用到正则表达式了 感谢这一题，让我回想起了被正则表达式支配的恐惧 12345678910class Solution(object): def myAtoi(self, str): \"\"\" :type str: str :rtype: int \"\"\" str1 = \"\" str1 = str.strip(\" \") str1 = int(*re.findall('^[\\+\\-]?\\d+', str1)) return min(max(str1, -2**31), 2**31-1) 这段正则表达式是和评论多次印证和比较得出来的（对不起，我太菜了= =），功能就是^从字符串开头[\\+\\-]?可能有一个加号或者减号，\\d+后面有多个数字 大致上这里就完成了，后面的就是判断一下范围 ok，这周事情多，身体还被体测搞废了，尽量不断吧。","path":"2019/11/11/leetcode - 字符串转换整数/","date":"11-11","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 实现 strStr()","text":"leetcode: 实现 strStr()实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 这一题的道理就遍历就好，只是需要考虑一下为空的情况 代码如下 1234567891011121314151617class Solution(object): def strStr(self, haystack, needle): \"\"\" :type haystack: str :type needle: str :rtype: int \"\"\" if needle == \"\": return 0 for i in range(len(haystack) - len(needle) + 1): for j in range(len(needle)): if haystack[i+j] != needle[j]: break if j == len(needle) - 1: return i return -1 今天也很短= =，没得办法，还有作业的嘛","path":"2019/11/08/leetcode-实现 strStr()/","date":"11-08","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 移除元素","text":"leetcode: 移除元素给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 这一题关键点就是只能用一个额外空间，那么就是说必须在原数组中修改，那么事情就变得简单了，我们可以用两个标记，标记一遍历，标记二写入，等遍历完了，那么也就移除完了。 代码如下 12345678910111213141516class Solution(object): def removeElement(self, nums, val): \"\"\" :type nums: List[int] :type val: int :rtype: int \"\"\" left = 0 right = 0 for i in nums: if i != val: nums[left] = nums[right] left += 1 right += 1 return left 啊~ 又是一道简单题，莫得办法，今天云顶之弈s2更新了，太快乐了，9光强无敌= =","path":"2019/11/07/leetcode - 移除元素/","date":"11-07","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 无重复字符的最长子串","text":"leetcode: 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 这个问题首先我们可以想到的就是暴力破解，（依稀记得以前一个数学老师的三大鬼才解法，暴力破解，数学归纳，容易证得= =），但是暴力破解就就要把所有情况考虑进去，我们可以算一下时间复杂度 设一长度为n的字符串，当考虑答案为n的情况就需要n^2的时间，然后一共有1 + 2 + 3 + 4…..n-1种情况，那么最坏要达到n^3以上的复杂度，所以我们最好不要用暴力破解 我们就采用了一种滑动窗口方法，故名思义，滑动窗口就是一个左右边界不确定变长的串，代码如下 123456789101112131415161718192021class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" l = [] //滑动窗口 count = 0 //最长串长度 Ncount = 0 //现在串的长度 left = 0 //窗口左边位置 right = 0 //窗口右边位置 for i in range(len(s)): //遍历字符串 Ncount+= 1 //每加一个字符，长度加一 while s[i] in l: //检查是否有重复 l.remove(s[left]) //左窗口不断右滑直到没有重复字符 left += 1 Ncount -= 1 if Ncount &gt; count: count = Ncount l.append(s[i]) return count 实际上，滑动窗口在计算机网络信息传递时有很重要的作用，这一题可以辅助学习 嘛~ 今天的leetcode就这样了，晚点要是做完了做一期B样条曲线 啊，不想上晚课啊艹","path":"2019/11/06/leetcode-无重复字符的最长字段/","date":"11-06","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 删除排序数组中的重复项","text":"leetcode: 删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 这个的思路很清楚，就简单的遍历一遍，把前几个数字的内容替换就好 123456789101112131415class Solution(object): def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) == 0: return 0 count = 0 for i in nums: if nums[count] != i: count += 1 nums[count] = i return count+1 这题比较简单，就到这里吧。 唉，我是真的懒。。。明天继续","path":"2019/11/05/leetcode-删除排序数组中的重复项/","date":"11-05","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"数据库实验二","text":"数据库实验二实验一已经完成了，虽然有点小插曲 我什么场面没见过 这场面我真没见过 事不宜迟，开始实验二 实验二要求:1．设计与建立上课考勤表****Attend_???，能登记每个学生的考勤记录包括正常、迟到、旷课、请假。能统计以专业为单位的出勤类别并进行打分评价排序，如迟到、旷课、请假分别扣2，5，1分。可以考虑给一初始的分值，以免负值。 2．为major表与stud表增加sum_evaluation 数值字段，以记录根据考勤表Attend_???(Attendance)中出勤类别打分汇总的值。 3．建立个人考勤汇总表stud_attend与专业考勤表major_attend，表示每个学生或每个专业在某时间周期（起始日期，终止日期）正常、迟到、旷课、请假次数及考勤分值。 4．根据major表中的值与stud中的值，为考勤表Attend输入足够的样本值，要求每个专业都要有学生，有部分学生至少要有一周的每天5个单元（12，34，56，78，90，没有课的单元可以没有考勤记录）的考勤完整记录，其中正常、迟到、旷课、请假 可以用数字或字母符号表示。 5．建立触发器，当对考勤表Attend表进行相应插入、删除、修改时，对stud表的sum_evaluation 数值进行相应的数据更新。 6．建立过程，生成某专业某时段（起、止日期）的考勤汇总表major_attend中各字段值，并汇总相应专业，将考勤分值的汇总结果写入到major表中的sum_evaluation中。 首先，这次的实验和上次不一样，几个条件之间是有关系的，为了捋清楚，我先从二这种比较明确的做起 增加打分汇总值代码如下 1234alter table major_J314 drop column sum_evaluation; //删除字段，备用alter table stud_J314 drop column sum_evaluation; //删除字段，备用alter table major_J314 add sum_evaluation int Default 100 Not NULL;alter table stud_J314 add sum_evaluation int Default 100 NOT NULL; 这个地方注意了，oracle必须NOT NULL 在 Default后面，不然报错= = 建立考勤表然后我们来捋一捋考勤表的字段与约束 统计学生，需要学生号SNO字段 考勤记录，需要记录ATTEND字段 需要统计以专业为单位，需要MajorNo字段 考勤需要记录时间，需要SDATE字段 四中把考勤一天分为5个单元，需要UNIT字段 建表如下： 123456789101112131415drop table attend_J314;create table attend_J314( SNO varchar(20), ATTEND int, MajorNo char(20), SDATE date, UNIT varchar(10), constraint aj_pk primary key(SNO, SDATE, UNIT)， constraint aj_unit check (UNIT in ('12','34','56','78','90')), constraint aj_attend check (ATTEND in ('0','1','2','5'))); 初步建表就这样了 对了，发现一个问题，千万不要在最后一个字段后面加逗号，他会把 ) 也当作字段读入，这个和css或者一些编程语言不一样了= = 建立个人考勤表和专业考勤表个人/专业考勤表 个人的表需要SNO学号/专业号MajorNo 需要开始日期SDate 需要结束日期EDate 需要正常次数NCount 需要迟到次数LCount 需要旷课次数ABCount 需要成绩score 开始建表 123456789101112131415161718192021222324252627282930313233drop table stud_attend_J314;drop table major_attend_J314;create table stud_attend_J314( SNO varchar(10), SDate date, EDate date, NCount int, LeCount int, LaCount int, ABCount int, constraint saj_pk primary key(SNO, SDate, EDate), constraint saj_sno_fk foreign key(SNO) references stud_J314(SNO));create table major_attend_J314( MajorNo varchar(10), SDate date, EDate date, NCount int, LeCount int, LaCount int, ABCount int, score int, constraint maj_pk primary key(MajorNo, SDate, EDate), constraint maj_sno_fk foreign key(MajorNo) references major_J314(MajorNo)); 同理，初步建表就这样了 插入数据又到了喜闻乐见的插（编）入（造）数（脑）据（洞）时间了，特别要求部分学生有一周一天五个单元的记录 代码如下 1234567891011121314151617181920212223242526insert into attend_J314 values('0902170314', '0', '02', to_date('20191028', 'YYYYMMDD'), '56');insert into attend_J314 values('0902170314', '1', '02', to_date('20191028', 'YYYYMMDD'), '78');insert into attend_J314 values('0902170314', '2', '02', to_date('20191029', 'YYYYMMDD'), '12');insert into attend_J314 values('0902170314', '0', '02', to_date('20191029', 'YYYYMMDD'), '78');insert into attend_J314 values('0902170314', '1', '02', to_date('20191030', 'YYYYMMDD'), '90');insert into attend_J314 values('0902170314', '0', '02', to_date('20191031', 'YYYYMMDD'), '56');insert into attend_J314 values('0902170314', '0', '02', to_date('20191101', 'YYYYMMDD'), '34');insert into attend_J314 values('0902170314', '0', '02', to_date('20191101', 'YYYYMMDD'), '90');insert into attend_J314 values('0903170101', '5', '02', to_date('20191028', 'YYYYMMDD'), '56');insert into attend_J314 values('0903170102', '0', '02', to_date('20191028', 'YYYYMMDD'), '78');insert into attend_J314 values('0903170102', '2', '02', to_date('20191029', 'YYYYMMDD'), '12');insert into attend_J314 values('0903170103', '0', '02', to_date('20191029', 'YYYYMMDD'), '78');insert into attend_J314 values('0903170105', '1', '02', to_date('20191030', 'YYYYMMDD'), '90');insert into attend_J314 values('0903170108', '2', '02', to_date('20191031', 'YYYYMMDD'), '56');insert into attend_J314 values('0903170109', '0', '02', to_date('20191101', 'YYYYMMDD'), '34');insert into attend_J314 values('0903170109', '5', '02', to_date('20191101', 'YYYYMMDD'), '90');insert into attend_J314 values('0904170101', '0', '02', to_date('20191028', 'YYYYMMDD'), '56');insert into attend_J314 values('0904170102', '1', '02', to_date('20191028', 'YYYYMMDD'), '78');insert into attend_J314 values('0904170102', '0', '02', to_date('20191029', 'YYYYMMDD'), '12');insert into attend_J314 values('0904170103', '0', '02', to_date('20191029', 'YYYYMMDD'), '78');insert into attend_J314 values('0904170105', '1', '02', to_date('20191030', 'YYYYMMDD'), '90');insert into attend_J314 values('0904170108', '0', '02', to_date('20191031', 'YYYYMMDD'), '56');insert into attend_J314 values('0904170109', '0', '02', to_date('20191101', 'YYYYMMDD'), '34');insert into attend_J314 values('0904170109', '0', '02', to_date('20191101', 'YYYYMMDD'), '90'); 在我准备插入的时候我发现一个问题，题设要求与实际需要都要是在stud和major表有的前提下的，所以我需要在attend表加上上面两个表的外键才对，添加如下重新建表 12345678910111213141516171819drop table attend_J314;create table attend_J314( SNO varchar(20), ATTEND int, MajorNo varchar(20), SDATE date, UNIT varchar(10), constraint aj_pk primary key(SNO, SDATE, UNIT)， constraint aj_unit check (UNIT in ('12','34','56','78','90')), constraint aj_attend check (ATTEND in ('0','1','2','5')), constraint aj_sno_fk foreign key(SNO) references stud_J314(SNO), constraint aj_MajorNo_fk foreign key(MajorNo) references major_J314(MajorNo)); 以此类推，stud_attend与major_attend两个表都需要加上SNO的外键约束 1234constraint saj_sno_fk foreign key(SNO) references stud_J314(SNO)constraint maj_sno_fk foreign key(MajorNo) references major_J314(MajorNo) 做到这一步，表，数据和关系都基本建立完成了，下一步就是触发器和过程了 先是触发器，要求在对attend表修改时，对stud_attend进行相应修改，那么问题来了，我们的stud_attend表还没有插入数据，那就先做数据插入吧= = 1select 'insert into stud_attend_J314 values (\"'||SNO||'\", to_date(\"20190901\", \"YYYYMMDD\"), to_date(\"20200101\", \"YYYYMMDD\"), 0, 0, 0, 100);' from stud_J314; 在我把数据插入完后发现上一步的insert又走早了，需要先做触发器再做插入才比较好 attend表触发器我的打算是，先修改stud_attend_J314表再通过stud_attend_J314表的触发器触发stud_J314的修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354create or replace trigger T_attend_J314 after insert or delete or update on attend_J314 for each rowbegin if inserting then update stud_J314 set sum_evaluation = sum_evaluation - :new.ATTEND where SNO = :new.SNO; /* if :new.ATTEND = 1 then update stud_attend_J314 set LeCount = LeCount + 1 where SNO = :new.SNO; elsif :new.ATTEND = 2 then update stud_attend_J314 set LaCount = LaCount + 1 where SNO = :new.SNO; elsif :new.ATTEND = 5 then update stud_attend_J314 set ABCount = ABCount + 1 where SNO = :new.SNO; elsif :new.ATTEND = 0 then update stud_attend_J314 set NCount = NCount + 1 where SNO = :new.SNO; end if; */ elsif deleting then update stud_J314 set sum_evaluation = sum_evaluation + :old.ATTEND where SNO = :old.SNO; /* if :old.ATTEND = 1 then update stud_attend_J314 set LeCount = LeCount - 1 where SNO = :old.SNO; elsif :old.ATTEND = 2 then update stud_attend_J314 set LaCount = LaCount - 1 where SNO = :old.SNO; elsif :old.ATTEND = 5 then update stud_attend_J314 set ABCount = ABCount - 1 where SNO = :old.SNO; elsif :old.ATTEND = 0 then update stud_attend_J314 set NCount = NCount - 1 where SNO = :old.SNO; end if; */ elsif updating then update stud_J314 set sum_evaluation = sum_evaluation - :new.ATTEND where SNO = :new.SNO; update stud_J314 set sum_evaluation = sum_evaluation + :old.ATTEND where SNO = :old.SNO; /* if :old.ATTEND = 1 then update stud_attend_J314 set LeCount = LeCount - 1 where SNO = :old.SNO; elsif :old.ATTEND = 2 then update stud_attend_J314 set LaCount = LaCount - 1 where SNO = :old.SNO; elsif :old.ATTEND = 5 then update stud_attend_J314 set ABCount = ABCount - 1 where SNO = :old.SNO; elsif :old.ATTEND = 0 then update stud_attend_J314 set NCount = NCount - 1 where SNO = :old.SNO; end if; if :new.ATTEND = 1 then update stud_attend_J314 set LeCount = LeCount + 1 where SNO = :new.SNO; elsif :new.ATTEND = 2 then update stud_attend_J314 set LaCount = LaCount + 1 where SNO = :new.SNO; elsif :new.ATTEND = 5 then update stud_attend_J314 set ABCount = ABCount + 1 where SNO = :new.SNO; elsif :new.ATTEND = 0 then update stud_attend_J314 set NCount = NCount + 1 where SNO = :new.SNO; end if; */ end if;end; 插入就不测试了，上面的都是例子，我们测试一下修改与删除 123delete from attend_J314 where SNO = '0904170105';insert into attend_J314 values('0904170105', '1', '02', to_date('20191030', 'YYYYMMDD'), '90');update attend_J314 set ATTEND = 5 where SNO = '0904170105'; 左调右调应该没什么问题了= = 下一步是建立一个过程，过程就是一个搜索并更新的过程 12345678910111213141516171819202122232425262728create or replace procedure p_attend_J314( Num in char, s_date in date, e_date in date)isa int := 0;scount int := 0;normal int := 0;leave int := 0;late int := 0;absent int := 0;begin for attend in (select ATTEND from attend_J314 where MajorNo = Num and SDATE &gt;= s_date and SDATE &lt;= e_date)loop scount := scount + 1; if attend.ATTEND = 0 then normal := normal + 1; elsif attend.ATTEND = 1 then leave := leave + 1; elsif attend.ATTEND = 2 then late := late + 1; elsif attend.ATTEND = 5 then absent := absent + 1; end if; end loop; scount := (scount * 100 - leave - late * 2 - absent * 5) / scount; insert into major_attend_J314 values(Num, s_date, e_date, normal, leave, late, absent, scount);end p_attend_J314; 下面就是对过程的测试了 1exec p_attend_J314(&apos;02&apos;,&apos;20-10月-2019&apos;,&apos;03-11月-2019&apos;);","path":"2019/11/02/数据库实验二/","date":"11-02","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://nomalbuthappy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"leetcode - 有效的括号","text":"leetcode: 有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 这题如果让我用C/C++就是用栈的知识了，对于括号不断压栈直到有相对应的消掉，现在用python也是一样的 12345678910111213141516class Solution(object): def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" dict = &#123;\"(\" : 1, \")\" : -1, \"&#123;\" : 2, \"&#125;\" : -2, \"[\" : 3, \"]\" : -3&#125; str_s = [] for i in s: if len(str_s) == 0: str_s.append(i) elif dict[i] + dict[str_s[-1]] == 0: del str_s[-1] else: str_s.append(i) return len(str_s) == 0; 评论区看到一些有趣的做法，对啊，python可以直接替换，替换到最后若为空就是真的 1234567class Solution: def isValid(self, s): while '&#123;&#125;' in s or '()' in s or '[]' in s: s = s.replace('&#123;&#125;', '') s = s.replace('[]', '') s = s.replace('()', '') return s == '' 简洁明了不过因为循环的问题需要遍历多次比如[[[]]]这样的就需要循环很多次浪费了时间 还有一个C的大佬，原本C就速度快，这个大佬这个几乎0ms= = 12345678910111213141516171819202122int length=0;//定义字符串长度while(*(s+length))length++;//获取字符串长度char* ptr=(char*)malloc(length/2);//分配内存空间memset(ptr,0,length/2);//初始化内存空间int i,a=0;for(i=0;i&lt;length;i++)&#123; if((*(s+i)=='(')||(*(s+i)=='&#123;')||(*(s+i)=='[')) &#123; a++; *(ptr+a)=*(s+i); &#125; //'('与')'的ASCII值差1，'['与']'，'&#123;'与'&#125;'的ASCII值差2 else if((*(s+i)==(*(ptr+a)+1))||(*(s+i)==(*(ptr+a)+2))) &#123; a--; &#125; else return 0;&#125;if(a) return 0;return 1; 简单来说，这题用栈还是快一些的 啊啊啊，今天还是简单题，不行，明天做道困难题= =，还是不太行，明天有课，做道中等题，后天做困难 关于自己的生活，我和你都不是读者，而是作者。至少结局，还是能自己说了算的。 -「银魂」","path":"2019/10/31/leetcode-有效的括号/","date":"10-31","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 合并两个有序链表","text":"leetcode: 合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 还是一道简单题，是对于两个已经有序了的链表的合并操作，思路就是不断取两个链表的链头进行比较，取小的值作为新链表的尾结点值，两个链表遍历到都为空时两个链表就合并为新链表了 12345678910111213141516171819202122232425262728293031323334class Solution(object): def mergeTwoLists(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" lhead = ListNode(0) lpre = lhead while l1 and l2: if l1.val &lt;= l2.val: a = ListNode(l1.val); lpre.next = a; l1 = l1.next; lpre = lpre.next; else: a = ListNode(l2.val); lpre.next = a; l2 = l2.next; lpre = lpre.next; while l1 != None: a = ListNode(l1.val); lpre.next = a; l1 = l1.next; lpre = lpre.next; while l2 != None: a = ListNode(l2.val); lpre.next = a; l2 = l2.next; lpre = lpre.next; return lhead.next; 可以发现在时间和内存上都是有问题，能通过测试但是可以做一些优化，直接用提供的链表结点，这样就省下了建立结点的空间与时间 123456789101112131415161718192021class Solution(object): def mergeTwoLists(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" lhead = ListNode(0) lpre = lhead while l1 and l2: if l1.val &lt;= l2.val: lpre.next = l1; l1 = l1.next; else: lpre.next = l2; l2 = l2.next; lpre = lpre.next; if l1 != None: lpre.next = l1; else: lpre.next = l2; 除了上面的解法，官方的解法还有一个直接调用函数的（python不仅包多，稀奇古怪的函数也多啊= =） 123456789101112class Solution: def mergeTwoLists(self, l1, l2): if l1 is None: return l2 elif l2 is None: return l1 elif l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2 今天看漫画的鬼才汉化组 打啵教程： 仪容仪表很重要 前提你得有女票 by全员已婚的飞橙汉化组 我酸了: - (","path":"2019/10/31/leetcode-合并两个有序链表/","date":"10-31","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 两数相加","text":"leetcode: 两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-two-numbers 这题是一道中等难度的题（可怜我这个彩笔前几天只敢做简单题），这题设计的一个关键就是链表 首先，链表中的两数相加应该是和加法一样各个位相加，而各个位相加的话就会有一个进位的问题，这题的关键就是处理这个进位的问题 代码如下： 12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" re = ListNode(0) //初始化一个链表节点，作为头节点 r = re //作为建立链表的节点 carry = 0 while(l1 or l2): x = l1.val if l1 else 0 y = l2.val if l2 else 0 s = carry + x + y carry = s // 10 r.next = ListNode(s % 10) r = r.next if (l1 != None): l1 = l1.next if (l2 != None): l2 = l2.next if (carry &gt; 0): r.next = ListNode(1) return re.next 其中有一个语法 1x = l1.val if l1 else 0 意思同 1234if l1: x = l1.valelse: x = 0 实际上这个还有一个优化的空间，就是在发现了l1 或 l2为空的时候让 r 指向非空的链，节约算法空间与时间 上面的方法确实可行，在一条链结束的时候若有进位，而后面又全都是9，那就需要一个循环，这样可以提高一定的效率，下次二刷的时候再实现吧 LPL联手出现保送决赛= =，但是skt是最强的: - )","path":"2019/10/27/leetcode-两数相加/","date":"10-27","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"自搭hexo博客","text":"自搭hexo博客教程hexo是一个可以轻量方便依托于githubpage的博客，原本我是自搭博客，从前端到后台全包干，但是这样不仅自己设计上面存在问题需要不断，修改越改心越累，也没办法把全部精力留在博客质量上，所以我还是选择了hexo，还省了一个服务器，美滋滋= = 注 以下教程的操作系统是window，linux请寻找其他相应教程或等待后续教程 准备工作 注册一个github账号 操作系统安装node.js。这个可以搜索官网免费下载安装后用 12node -vnpm -v 检查是否安装成功 安装git，同样是搜索官网下载安装好后，用 1git --version 检查一下环境 下载3.x以后版本的hexo 先创建一个文件夹用于保存hexo，然后右键gitbash，输入 12345npm install hexo-cli -g //等待进度条读完后就下载完成了hexo init myblog //初始化一个myblog，也可以是其他名字cd myblog //进入myblog文件夹hexo g //生成博客hexo server //生成预览 默认localhost:4000可以浏览 创建仓库新建一个仓库，在右上角的加号new repository，创建一个和用户名相同的仓库，后加.github.io 只有这样在部署githubpage的时候才会被识别，所以从这个角度来说一个用户只能有一个github提供的域名 生成SSH并添加到github回到git bash中 12345git config --global user.name &quot;yourname&quot; //存入你的github用户名git config --global user.email &quot;youremail&quot; //存入你注册时用的邮箱git config user.name //检查一遍你的输入git config user.email //同上ssh-keygen -t rsa -C &quot;youremail&quot; //生成SSH，在电脑里找到它，返回有提示位置 其中，我们要用的是公钥公开给github，就是哪个id_rsa.pub，复制里面的内容，在右上角用户找到setting，点击找到SSH keys新建一个把id_rsa.pub复制进去，再回到gitbash 1ssh -T git@github.com //返回success就是部署成功 配置博客打开myblog中的_config.yml配置文件，找到deploy，修改为 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 再回到gitbash 1234npm install hexo-deployer-git --save //安装deploy-git用于推送到github上hexo clean //用于清理之前生成的文件hexo g //generate的缩写，生成博客hexo d //deploy的缩写，部署到github 过一会儿，你就可以在http://yourname.github.io上看到你的博客了，他现在还很简单，没有内容没有主题 内容在source/_post中添加 主题可以直接找，每个主题的要求不同配置方法也不同所以基本上都有配置文档或教程 以上 ps 有点没写好，很多瑕疵 ma，算了，反正没有人看= = 有点冷啊，咸鱼落泪 : - )","path":"2019/10/25/自搭hexo博客/","date":"10-25","excerpt":"","tags":[]},{"title":"leetcode - 最长公共前缀","text":"leetcode: 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot; 首先，这一题的思路是从头到尾两辆比较，上一次比较的公共前缀用于下一次比较，代码如下： 123456789101112131415161718192021222324class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" if strs == []: return \"\" else: s = strs[0] for i in range(1, len(strs)): temp = \"\" if strs[i] == \"\": return \"\" else: for j in range(min(len(strs[i]), len(s))): if(strs[i][j] == s[j]): temp += s[j] if j == min(len(strs[i]), len(s)) - 1: s = temp else: s = temp; break; return s 可以看到，这个方法我们用了很多的特殊情况处理，比如只有空list，list中有空串等（一次次出错中补出来的= =） 评论中有一些启发的思路，比如说，字符串是可以比较大小的，那么不就可以直接只比较最大和最小的两项吗 代码如下 123456789101112131415161718class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" temp = \"\" if strs == []: //也能写成if not strs return \"\" else: smax = max(strs) smin = min(strs) for i in range(min(len(smax), len(smin))): if smax[i] == smin[i]: temp += smax[i] else: break return temp 另外就是利用zip函数，把str对齐压缩然后去重，取最短的对象的函数特性正好可以利用到，在list中找到长度大于1前的就是公共前缀，有点神奇： 1234567891011class Solution(object): def longestCommonPrefix(self, strs): if not strs: return \"\" ss = list(map(set, zip(*strs))) res = \"\" for i, x in enumerate(ss): x = list(x) if len(x) &gt; 1: break res = res + x[0] return res 这是今天的份了。 今天雨有点大，鞋也湿了，头有点痛晚上还有实验。。。 心塞的看看桌上的老婆，发现双十一买不起新老婆 呵，男人","path":"2019/10/25/leetcode-最长公共前缀/","date":"10-25","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 罗马数字转整数","text":"leetcode: 罗马数字转整数例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 罗马数字转整数乍一看觉得需要多方面的考虑比如每个字符之间的组合分别考虑之类的，但是再细看我们可以发现，实际上我们做计算时它遵循的只有两个规律 左边大于右边时加上这个左边的数 左边小于右边时减去这个左边的数 那么我们就可以着手编程了: 12345678910class Solution(object): def romanToInt(self, s): d = &#123;'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000&#125; ans=0 for i in range(len(s)): if i&lt;len(s)-1 and a[s[i]]&lt;a[s[i+1]]: ans-=a[s[i]] else: ans+=a[s[i]] return ans 膜拜大佬，有个两行就解决的大佬，分析一下他的解法 123456class Solution: def romanToInt(self, s: str) -&gt; int: d = &#123;'I':1, 'IV':3, 'V':5, 'IX':8, 'X':10, 'XL':30, 'L':50, 'XC':80, 'C':100, 'CD':300, 'D':500, 'CM':800, 'M':1000&#125; return sum(d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s)) 链接：https://leetcode-cn.com/problems/roman-to-integer/solution/2-xing-python-on-by-knifezhu/ 首先用map把各个字符的数字列出来，不过大佬与众不同的是这里用了遍历的方法，就是上面我说的每个字母之间的组合分别考虑全部列出 比如，IV为4，先读I为1，再读V，IV为3，加起来就是4达到了IV是4的效果再从头到尾遍历一边就可以解决问题 今日份完工！ 话说不知道是脑抽还是什么买了一桶比我手臂还粗的饼干，真好，能吃一年了: - )","path":"2019/10/24/leetcode-罗马数字转整数/","date":"10-24","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"数据库实验 - oracle","text":"数据库实验选课的时候选了一门大型数据库，但是开学以来都没好好学习过 (当个人吧= =)，我本来以为以我原本的mysql与sqlserver的基础问题应该不大，但是oracle真是让我失策了，还有pl/sql令人头大，以下博客是自救过程中的学习与感悟 实验一 oracle安装首先是Oracle的安装，用任何搜索引擎搜索oracle然后打开download页面找到11c以后的版本下载 但是下载之前需要注册登陆一系列吧啦吧啦的操作，所以我这个小机灵鬼发现一个小办法= = 把下载按钮看一下开发者模式的链接，然后把链接复制下来用迅雷，bittorrent之类的下载器下载 12c版本的，以下为链接 https://download.oracle.com/otn/nt/oracle12c/121020/winx64_12102_database_1of2.zip https://download.oracle.com/otn/nt/oracle12c/121020/winx64_12102_database_2of2.zip 注意两个都要下载并解压到同一个文件夹，路径不带中文 双击setup.exe进行安装，后面按照自己的需要安装即可，有无法把握的细节可以自行搜索或者在留言栏留言 使用sqlplus打开命令行控制台cmd，输入 1sqlplus system/密码 在前面的安装过程中设置的密码，若未设置默认为manager 创建一个新用户： 1create user username identified by password; 给用户授权： 1grant resource, connect to username; 连接用户： 1connect username/password *2. *根据要求建立如下表 定义基本表格major????（专业）与stud_???(学生），关系模式如下(类型长度自定义)： major_???(MajorNo专业编号 Primary key, MNAME 专业名称,loc 地址 in(主校区，南校区，新校区，铁道校区，湘雅校区),mdean 专业负责人)） stud_???(SNO primary key, SNAME, SEX (男，女，其他),TEL ,E-MAIL (基本格式判断), birthday &gt;=’19990731’ ,MNO 班长学号 FK，MajorNo 专业编号 FK ) 其中学号的第3，4位为MajorNo（专业编号）。 创建专业表代码如下 12345678create table major_J314 ( MajorNo char(20) primary key, MNAME varchar(50), loc varchar(20), mdean varchar(20), constraint mj_loc check (loc IN ('主校区', '南校区', '新校区', '铁道校区', '湘雅校区'))); 测试check语句是否生效 12insert into major_J314 values('02', '计算机科学与技术', '123', '张祖平'); --违反条例insert into major_J314 values('02', '计算机科学与技术', '南校区', '张祖平'); --创建成功 注意，在插入过程中如果发现对表空间 ‘USERS’ 无权限，那么在system的权限下执行语句 1alter user username quota unlimited on users 创建学生表代码如下 12345678910111213141516171819202122create table stud_J314 ( SNO varchar(20) primary key, SNAME varchar(20), SEX varchar(5), TEL varchar(20), E_MAIL varchar(20), birthday date, MNO char(20), MajorNo char(20), constraint sj_sex check (sex IN ('男','女','其他')), constraint sj_E_MAIL check (REGEXP_LIKE (E_MAIL,'[a-zA-Z0-9._%-]+@[a-zA-Z0-9._%-]+\\.[a-zA-Z]&#123;2,4&#125;')), constraint sj_birthday check (to_char(birthday, 'yyyymmdd') &gt; '1999-07-31'), constraint sj_MNO foreign key (MNO) references stud_J314(SNO), constraint sj_MajorNo foreign key (MajorNo) references major_J314(MajorNo), constraint sj_sno check (substr(SNO, 3, 2) = MajorNo)); 测试成功用例 12insert into major_J314 values('02', '计算机科学与技术', '南校区', '张祖平');insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); 这个表的创建比上面的表明显困难，因为添加了更多的约束，我把约束与测试拿出来一个个分析 SEX性别必须是’男’,’女’,’其他’中的一个，这个我们在上一个表中已经实现 12insert into stud_J314 values ('0902170314', '颜灿', '1', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); --违反检查约束条件SJ_SEXinsert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); --已创建一行 E_MAIL需要约束成XXX@XXX.XXX的格式，为了更加精确，我用了oracle允许的正则表达式[a-zA-Z0-9.%-]+@[a-zA-Z0-9.%-]+.[a-zA-Z]{2,4}来对格式进行规范 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); --违反检查约束条件SJ_E_MAIL MNO与MajorNo需要添加外键，MajorNo直接与之前的Major表关联成为外键，但是MNO我思来想去还是觉得他应该成为自己的表的主键的外键。 注意 当MajorNo与自己的主键关联时，也就是说插入班级的每个数据之前必须先插入班长的数据！！！否则就会出现外键找不到父项关键字的报错！！！ 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170313', '02'); --未找到父项关键字 然后就是生日的约束，这里需要用到 date 的数据类型，以及char与date之间的转化to_char(birthday, ‘yyyymmdd’)，to_date(birthday, ‘YYYYMMDD’)。 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('19981010', 'YYYYMMDD'), '0902170314', '02'); --违反检查约束条件SJ_BIRTHDAY 学号的第3，4位为MajorNo，所以我们需要截断字符串，需要用到方法substr(字符串, 第几个字符, 截取几个字符) 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '03'); --违反检查约束条件SJ_SNO 插入样本数据插入3个专业，如计算机科学与技术，物联网工程，数据科学与大数据技术，每个专业不少于10个人，其中包括自己的信息。 测试相关的完整性约束，并注意保留出错的提示，分析出错的原因。 根据上面分析的约束，我们需要先插入没有外键的表 major_U314 123insert into major_J314 values('02', '计算机科学与技术', '南校区', '张祖平');insert into major_J314 values('03', '物联网工程', '南校区', '张祖平');insert into major_J314 values('04', '数据科学与大数据技术', '南校区', '张祖平'); 下一个插入的就是学生表，但是注意了，学生表中由于约束到的是自己的主键，需要先插入班长的信息 1234567891011121314151617181920212223242526272829303132333435--班长学生insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0903170314', 'a', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '03');insert into stud_J314 values ('0904170314', 'b', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');--非班长学生insert into stud_J314 values ('0902170101', '1', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170102', '2', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170103', '3', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170104', '4', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170105', '5', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170106', '6', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170107', '7', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170108', '8', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170109', '9', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0903170101', '1', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170102', '2', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170103', '3', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170104', '4', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170105', '5', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170106', '6', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170107', '7', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170108', '8', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170109', '9', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0904170101', '1', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170102', '2', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170103', '3', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170104', '4', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170105', '5', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170106', '6', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170107', '7', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170108', '8', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170109', '9', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');--其他以此类推 实现权限控制为每个学生建立相关用户，实现权限控制，每个学生可查询自己的信息，班长可查询本班所有学生信息；为每个专业负责人建立用户，每个专业负责人可查询本专业所有学生信息。 首先我要先把用户建立好 1234567select MajorNo from major_J314;select MNAME from major_J314; //以上两行用来看= =select 'create user u'||MajorNo||' identified by p'||MajorNo||';' from major_J314;select 'drop user u'||MajorNo||';' from major_J314; //删除用户，这里是写了备用select SNO from stud_J314;select 'create user u'||SNO||' identified by p'||SNO||';' from stud_J314;select 'drop user u'||SNO||';' from stud_J314; //删除用户，这里是写了备用 划重点 这里的select ‘’语句只有选择出所有合适语句的作用而不会运行那么，我们就要先把语句选出来存起来再全部运行 先建立一个txt或sql文件，写入 1234567891011121314151617clear screenconn U_J314/YcYyj1234 连接用户名与密码spool offset heading offset echo offset feedback offspool d:\\blog\\user.txt选出后存储的地址文件，可以用txt---选择语句，注意，只有选择语句会留下记录---spool offset heading onset echo onset feedback onspool d:\\blog\\demo.txt运行过程的记录，同样用令一个文件记录@d:\\blog\\user.txt 运行user的内容spool off 但是，在我实际创建的过程中发现一个问题 — 权限不足= = 创建用户就需要系统管理员的权限了 1grant dba to U_J314(这里用自己的用户名); 下一步是每个人的权限 12select 'grant connect to u'||MajorNo||';' from major_J314;select 'grant connect to u'||SNO||';' from stud_J314; 建立一个视图并给予视图的权限 123456create view V_J314 as select * from stud_J314 where 'u'||SNO=user or 'u'||MNO=user or 'u'||majorNo=user;grant select on V_J314 to public;--测试数据select * from U_J314.V_J314 心态崩了，真就没办法过啊 补充之前和个沙雕一样，想一想不如每个人建立一个视图 代码如下 12345678select 'drop view V_'||SNO||';' from stud_J314;select 'create view V_'||SNO||' as select * from stud_J314 where SNO = '||SNO||' or MNO = '||SNO||';' from stud_J314;select 'grant select on V_'||SNO||' to u'||SNO||';' from stud_J314;select 'drop view V_'||MajorNo||';' from major_J314;select 'create view V_'||MajorNo||' as select * from stud_J314 where MajorNo='||MajorNo||';' from major_J314;select 'grant select on V_'||MajorNo||' to u'||MajorNo||';' from major_J314;测试数据select * from U_J314.V_(学号或年级号) 测试通过，任务完成: - )","path":"2019/10/23/数据库实验/","date":"10-23","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://nomalbuthappy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"leetcode - 整数反转","text":"leetcode: 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-integer 首先，反转整数需要考虑两点，一是是否有负号，有符号需要把符号放到最前面，二是末尾有没有0，有0需要去掉，因为数字首位是不能为零的。 考虑到python取模10时结果会是正数，所以把数字转为字符处理更为方便 另外，题设假设环境只能存储得下32位int整型数字，python不需要考虑数字长度，所以我们直接用if判断数字大小 代码如下： 12345678910111213class Solution: def reverse(self, x: int) -&gt; int: if x == 0: return 0 str_x = str(x) x = '' if str_x[0] == '-': x += '-' x += str_x[len(str_x)-1::-1].lstrip(\"0\").rstrip(\"-\") x = int(x) if -2**31&lt;x&lt;2**31-1: return x return 0 注意到其中用了[len(str_x)-1::-1]，意义是从len(str_x)开始，以-1递减的方式截取，达到反取的作用，第二位不写默认是0 lstrip方法，表示截取最左边的某个字符，多个重复全部截取 rstrip方法同上不过是截取右边 评论大佬中也有不处理为字符串的方法，就是对数字做取余处理，这里贴一下代码以供学习： 123456789101112131415161718192021222324class Solution: def reverse(self, x: int) -&gt; int: # 避免python负数取模的特性，改为对正数取整 num: int = x if x &gt; 0 else -x ans: int = 0 MAX_VALUE = 2147483647 MIN_VALUE = -2147483648 while(num != 0): pop: int = num % 10 if x &gt; 0: if (ans &gt; MAX_VALUE // 10) or (ans == MAX_VALUE // 10 and pop &gt; 7): # 正溢出 return 0 elif x &lt; 0: if (ans &gt; -MIN_VALUE // 10) or (ans == -MAX_VALUE // 10 and pop &gt; 8): # 负溢出 return 0 ans = ans * 10 + pop num //= 10 return ans if x &gt; 0 else -ans 想起樱木花道的经典台词：安西教练，你最光荣的时候是什么时候，是在日本国家队的时候吗？而我，只有现在了！ 菜鸟坚持一天至少一篇，先从简单起，慢慢来吧。","path":"2019/10/23/leetcode-整数反转/","date":"10-23","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 两数之和","text":"leetcode: 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 对这道题一开始的思路是两套循环遍历找到为目标值的两个数，代码如下: 123456class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if(nums[i] + nums[j] == target): return [i, j] 循环遍历一遍，时间复杂度是n^2，可以通过但是非常常规且有时会超时 经过评论大佬的启迪，做一次排序后首尾递进显然更快，复杂度为排序的nlogn 12345678910111213class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: sorted_id = sorted(range(len(nums)), key=lambda k: nums[k]) head = 0 tail = len(nums) - 1 sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]] while sum_result != target: if sum_result &gt; target: tail -= 1 elif sum_result &lt; target: head += 1 sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]] return [sorted_id[head], sorted_id[tail]] 这个速度明显会更快，但更花费空间 这样还不够，发现比较的都是数字，那么就有了更快的办法—hash字典 123456789class Solution: def twoSum(self, nums, target): hashmap = &#123;&#125; for index, num in enumerate(nums): another_num = target - num if another_num in hashmap: return [hashmap[another_num], index] hashmap[num] = index return None 用hash字典大大增加了内存但是速度快到了n 还是图样图森破 这是第一天份的，明天继续= =","path":"2019/10/23/leetcode两数之和/","date":"10-23","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 回文数","text":"leetcode: 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 这一题和整数反转很像，都需要给数做一个反转，但是从转为字符串的角度来看，反而更加简单了 代码如下： 12345678class Solution: def isPalindrome(self, x: int) -&gt; bool: str_x = str(x) x = '' if str_x[len(str_x) - 1::-1] == str_x: return True else: return False 进阶任务：如何在不转为字符串的前提下解决这个问题 在不转为字符串的前提下，我们只要用数字的方法计算出反转后的数字大小进行比较就可以达到目的 代码如下： 1234567891011121314class Solution: def isPalindrome(self, x: int) -&gt; bool: if x &lt; 0 : return False m,n = x,0 while m: n = n*10 + m%10 m = m//10 if x == n: return True else: return False 今天的比较简单，留空看看大型数据库吧= = 我能够允许你逃避过去，不过至少从现在或者明天开始都不要再逃避。 -「无头骑士异闻录」","path":"2019/10/23/leetcode-回文数/","date":"10-23","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"212 23事","text":"212 23事这篇博客的内容来自博主波澜不惊的日常，记下来当作回忆 为了保护个人隐私，以下人名全部由字母w，y，z，h代替 该博客将不定期更新，全凭心情 1.dai作家z: 我说啊，不是有一种学习方法叫渗透压学习法吗？ y: 是啊，就是那个睡觉的时候把书放在枕头下，然后由于书里的知识渗透压比大脑大，会不断渗入大脑嘛 z: 对啊，但是你不感觉奇怪吗？这个效应应该发生在液体之间，而书和大脑都是固体，怎么发生这个作用？ y: 分子的无规则运动也可以发生在固体和固体之间啊，像那个金块和铅块 h: 你还没考虑知识可能会沉降，那就是说你脑袋里的知识可能会往书里走 z: 那我早上一觉起来不是发现书的页数变多了？？？ y: 那你不就成了作者了，从你的知识储备来看，会是嘎啦game CG集= = z: 沉啦，那我也是dai作家啦 2. 杀室友晚上放学的时候 h: 今天晚上一定要早睡！ y: 不可能的，每天都这么说，你看哪天早睡了？ h: 如果我超过1点，每晚睡10分钟 y: ？？？ h: 我就杀一个室友 y: = =||| h: = = y: ？？？？？？！！！！！！ 在一顿操作猛如虎以后，凌晨四点半了 y: h，你还记得晚上说过什么吗？ h: = = z: 他说了什么啊 y: 他说每超过一点钟10分钟睡觉 h: 我就杀一个室友 z: 你也太狠了嗷~~ y: 不如随机杀一个，另外两个直接保研 h: 那就杀你吧 y: 不太行，我得套复活甲 z: 现在四点半，算起来要杀21个室友，一个复活甲不太行 y: 现在我们有三个人，每个人把装备栏套满，那就是18条命，艹 z: h，我们可不可以等个复活甲冷却 h: zzzzZZZZ y: = = z: = = w: = = 3. 谁的锅w在看斗罗大陆动画 w: 我发现宁荣荣的那个比柳二龙的还要大 y: 那不就是建模的锅咯 z: 嗯？升调 剑魔又背锅咯？怎么不是剑圣的锅啦 y: ？？？ w: 行吧，那就是剑圣的锅 h: 好，决定了，就是剑姬的锅","path":"2019/10/01/212-23事/","date":"10-01","excerpt":"","tags":[{"name":"日常","slug":"日常","permalink":"https://nomalbuthappy.github.io/tags/%E6%97%A5%E5%B8%B8/"}]}]}