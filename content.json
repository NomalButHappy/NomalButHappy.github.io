{"meta":{"title":"badEgg","subtitle":null,"description":null,"author":"badEgg","url":"https://nomalbuthappy.github.io","root":"/"},"pages":[{"title":"comment","text":"有什么想说的就留在这里吧:-)","path":"comment/index.html","date":"10-23","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"10-23","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"10-23","excerpt":""},{"title":"about","text":"关于我新的博客，新的开始。 这次绝对不鸽！ 真的？ 应该吧….. 标签：咸鱼，翻不了身的那种，代码控，手办控，妹控，魔法师（初级火球术）","path":"about/index.html","date":"10-23","excerpt":""}],"posts":[{"title":"不同年代的经典游戏","text":"不同年代的经典游戏动画与游戏设计的作业，实际上我对游戏的历史也十分有兴趣，从小时候玩的简单手游马里奥，记得“老好人”是性能最好的赛车，到后面玩的qq飞车，孤胆枪手。到现在常打的moba，单机虐杀原形，鬼泣5（恶魔五月哭，笑），还有一些剧情推进向的文字游戏，嘎啦game，还有掌机gm，联机的mc。 游戏在进步，很多原因是开发/团队的努力，他们让游戏有了不同的乐趣点与成就感（同样这也是因为硬件的进步）。 为了从游戏的发展历史中学习，我打算对不同年代经典游戏分类和内容可玩性进行记录，用于学习和搞事。 当然，这不是一次就能完成的，还是要慢慢完善ing 1958 Tennis for Two 1962 Spacewar 1971 Computer Space 1972 Pong 1973 Space Race 1974 Gran Trak 10 Basketball 1975 Gun Fight 1976 Breakout Death Race 1977 Combat Road Champions 1978 Space Invaders Super Speed Race V 1979 Asteroids Randar Scope 1980 Pac-Man Battlezone 1981 Donkey Kong Turbo 1982 Q*bert Pole Position 1983 Bomberman Punch-Out Starwars 1984 Tetris PaperBoy Duck Hunt I, Robot 1985 Super Mario Bros Space Harrier 1986 The Legend of Zelda OutRun 1987 After Burner 1988 Winning Run 1989 Hard Drivim 1990 Galaxian 3 1991 Starblade 1992 Virtua Racing 1993 Ridge Racer 1994 Virtua Fighter 2 1995 Virtua Cop 2 1996 Virtua Figter 3 1997 The Lost Eorld: Jurassic Park 1998 Sonic Adventure 1999 Shenmue 2000 The Bouncer 2001 Dead or Alive 3 2002 Mafia: The City of Lost Heaven 2003 OutRun 2 2004 Doom 3 2005 First Encounter Assault Recon(FEAR) 2006 Gears of War 2007 Crysis 2008 Crysis Warhead 2009 Shattered Horizon 2010 Metro 2033 2011 Crysis 2 2012 Far Cry 3 2013 Ryse: Son of Rome 2014 Assassin’s Creed Unity 2015 The Order: 1886 2016 Battlefield 1 2017 Horizon Zero Down 2018 God of War","path":"2020/03/02/不同年代的经典游戏/","date":"03-02","excerpt":"","tags":[]},{"title":"邮箱发送天气提醒","text":"邮箱发送天气提醒这个在网上还算是比较多的，主要功能就是调用和风天气api或者爬取天气，定时发送邮件到指定的邮箱，起到一个报告的作用 但是，这个也被诟病没有用—-打开手机就能看到天气还需要这样的邮件嘛。但是从另一个角度来说也不是完全没用，比如先设置好，定时发送服务器中的报告来提防服务器出事或者说找个语料包，定时给女朋友发个问候之类的，最次，也是一个学习的过程啊（笑哭） 我就大概描述一下发送天气提醒的过程及关键代码 配置天气的api接口这里常用的免费api就是和风天气了，虽然免费有一些限制使用，但是比专门爬取是要好上很多了。 *注：由于图片麻烦，我会尽量使我的描述清楚不用配图，除了要做开箱:-)，那就没办法了 首先登陆和风天气，按照提示注册，这个不需要多说 回到首页，找到天气api（右上角），进入登陆进入控制台 在左边的控制台找到应用管理，新建一个应用，即新建一个自己的接口 新建完成后找到新建的应用，点击编辑，输入Key的名称与类型，类型用web api就好 到这里算是把接口配置好了 调用已配置的接口对于网站的接口就web请求获取json值就好，和风天气有提供文档说明，这里可以自己选择配置。 完事具备，现在只差调用了 12345678910111213141516171819202122import requestsimport jsonurl = 'https://free-api.heweather.net/s6/weather/forecast?location=衡阳&amp;key=45a7ae9c8ebd4660a0e1a9c93e2f5b2a'res = requests.get(url)res = json.loads(res.text)a = res['HeWeather6'][0]['basic']#print(result)result = res['HeWeather6'][0]['daily_forecast']#print(result)city = a['admin_area']+a['location']print(city)names = ['城市','时间','天气状况','最高温','最低温','日出','日落']for data in result: date = data['date'] cond = data['cond_txt_d'] max = data['tmp_max'] min = data['tmp_min'] sr = data['sr'] ss = data['ss'] print(city,date,cond,max,min,sr,ss) 我这里调用的衡阳的天气，得到的print为 1234湖南衡阳湖南衡阳 2020-02-09 阴 10 6 07:09 18:17湖南衡阳 2020-02-10 小雨 11 8 07:09 18:18湖南衡阳 2020-02-11 阵雨 17 9 07:08 18:19 显然，调用成功了（假装没有调试过） 用邮件发送天气到目标邮箱自动发邮件的话一般来说需要一个域名服务器，不过这个可以用开启qq邮箱的stmp服务来实现。 登陆qq邮箱，在设置中找到账户，找到POP3/SMTP服务，根据提示打开服务并记录下授权码（或者说是密码），这就是申请自动发邮件的关键。 下面就是代码环节 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# -*- coding: utf-8 -*-import csvimport timeimport jsonimport requestsimport smtplibfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultiparturl = 'https://free-api.heweather.net/s6/weather/forecast?location=衡阳&amp;key=45a7ae9c8ebd4660a0e1a9c93e2f5b2a'today_time = time.strftime('%Y-%m-%d', time.localtime(time.time()))def get_weather_data(): res = requests.get(url) res.encoding = 'utf-8' res = json.loads(res.text) result = res['HeWeather6'][0]['daily_forecast'] location = res['HeWeather6'][0]['basic'] city = location['parent_city'] + location['location'] names = ['城市', '时间', '天气状况', '最高温', '最低温', '日出', '日落'] with open('today_weather.csv', 'w', newline='')as f: writer = csv.writer(f) writer.writerow(names) for data in result: date = data['date'] cond = data['cond_txt_d'] max = data['tmp_max'] min = data['tmp_min'] sr = data['sr'] ss = data['ss'] writer.writerows([(city, date, cond, max, min, sr, ss)]) send_email()def send_email(): # 设置邮箱的域名 HOST = 'smtp.qq.com' # 设置邮件标题 SUBJECT = '%s日份天气预报信息，请查收'%today_time # 设置发件人邮箱 FROM = '271370166@qq.com' # 设置收件人邮箱 TO = '271370166@qq.com' # 可以同时发送到多个邮箱 message = MIMEMultipart('related') # --------------------------------------发送文本----------------- # 发送邮件正文到对方的邮箱中 message_html = MIMEText(\"%s日份天气预报到账啦，请查收\" % today_time, 'plain', 'utf-8') message.attach(message_html) # -------------------------------------添加文件--------------------- # today_weather.csv这个文件 message_xlsx = MIMEText(open('today_weather.csv', 'rb').read(), 'base64', 'utf-8') # 设置文件在附件当中的名字 message_xlsx['Content-Disposition'] = 'attachment;filename=\"today_weather.csv\"' message.attach(message_xlsx) # 设置邮件发件人 message['From'] = FROM # 设置邮件收件人 message['To'] = TO # 设置邮件标题 message['Subject'] = SUBJECT # 获取简单邮件传输协议的证书 email_client = smtplib.SMTP_SSL(HOST) # 设置发件人邮箱的域名和端口，端口为465 email_client.connect(HOST, '465') # ---------------------------邮箱授权码------------------------------ result = email_client.login(FROM, 'ellnzvqenuclcaab') print('登录结果', result) email_client.sendmail(from_addr=FROM, to_addrs=TO.split(','), msg=message.as_string()) # 关闭邮件发送客户端 email_client.close()get_weather_data() 运行以后发现，邮件就已经以csv的格式发送到邮箱里了。注意，这里我用的是python3.7，不同版本使用会有细微差别，所以需要一点调整，无伤大雅。 现在是发送一个天气的CSV附件，但是这还不是我所想要的内容，我希望把这个内容提取到邮件内容里，比如 主子/小主： ​ 今天XXX的天气是XXX，温度在XX和XX之间，与昨天相比更冷/热了，注意保暖:-)。今天有什么代办事项（课程），服务器有什么记录balabala 那这是下一步的事，今天因为多吃了一粒米心情不好就不继续写了，明天再继续写。 我是分割线 把内容提取到邮件之中","path":"2020/02/10/邮箱发送天气提醒/","date":"02-10","excerpt":"","tags":[]},{"title":"tensorflow nmist库手写数字识别","text":"tensorflow nmist库手写数字识别上次写了tensorflow的安装过程，这次就是梳理深度学习的’hello world’–mnist手写数字库，老实说，在家写了不少东西，但是在家一点干劲都没有，不想写博客。挨千刀的病毒:-( nmist是一个数字库，现在梳理一下用这个库学习手写数字的过程。 导入库一共三个库 第一个就是关键的tf训练库，为了方便起个别名tf 第二个是数学库numpy用来做一些数字矩阵处理 第三个是matplotlib库，用来做图看手写数字的图片 123import tensorflow as tfimport numpy as npimport matplotlib.pyplot as plt 导入nmist库并处理这里是打算构建卷积神经网络 根据官方文档，导入过程就如下 1234mnist = tf.keras.datasets.mnist(x_train, y_train), (x_test, y_test) = mnist.load_data()print(x_train.shape, y_train.shape)print(x_test.shape, y_test.shape) 扩充图片可以看到，(x_train, y_train) 训练集中，有60000个 28X28的图片，这个地方需要做一个填充到32 X 32的步骤，由于是初学，所以并不了解这么做的用意，标注一下，后面求证 扩充方式是图片上下左右各扩充两个单位 123x_train = np.pad(x_train, ((0, 0), (2, 2), (2, 2)), 'constant', constant_values=0)x_test = np.pad(x_test, ((0, 0), (2, 2), (2, 2)), 'constant', constant_values=0)print(x_train.shape) 归一化然后就是数值的归一化，这里的数据是灰度图,所以可以直接知道最大值是255.最小值是0 再有就是为了方便训练，在多加一个维度，相当于把每个值再单独计算为一个维度，就是一个通道 12345678x_train = x_train.astype('float32')x_train /= 255x_train = x_train.reshape(x_train.shape[0], 32, 32, 1)print(x_train.shape)x_test = x_test.astype('float32')x_test /= 255x_test = x_test.reshape(x_test.shape[0], 32, 32, 1) 构造模型这次学习构造的是一个卷积神经网络，分为以下几层 第一层卷积层，激活函数是relu 1tf.keras.layers.Conv2D(filters=6, kernel_size=(5, 5), padding=&apos;valid&apos;, activation=tf.nn.relu, input_shape=(32,32,1)) 第二层池化层 1tf.keras.layers.AveragePooling2D(pool_size=(2, 2), strides=(2,2), padding='same') 其余层同理 总模型如下 123456789101112model = tf.keras.models.Sequential([ tf.keras.layers.Conv2D(filters=6, kernel_size=(5, 5), padding='valid', activation=tf.nn.relu, input_shape=(32,32,1)),#relu tf.keras.layers.AveragePooling2D(pool_size=(2, 2), strides=(2,2), padding='same'), tf.keras.layers.Conv2D(filters=16, kernel_size=(5, 5), padding='valid', activation=tf.nn.relu), tf.keras.layers.AveragePooling2D(pool_size=(2, 2), strides=(2,2), padding='same'), tf.keras.layers.Flatten(), tf.keras.layers.Dense(units=120, activation=tf.nn.relu),# tf.keras.layers.Conv2D(filters=120, kernel_size=(5,5),strides=(1,1),activation='tanh',padding='valid'),# tf.keras.layers.Flatten(), tf.keras.layers.Dense(units=84, activation=tf.nn.relu), tf.keras.layers.Dense(units=10, activation=tf.nn.softmax) ]) 训练模型训练次数是10次，一次训练取64个，学习率是0.001 123456789101112131415161718192021num_epochs = 10batch_size = 64learning_rate = 0.001# 优化器adam_optimizer = tf.keras.optimizers.Adam(learning_rate)model.compile(optimizer=adam_optimizer, loss=tf.keras.losses.sparse_categorical_crossentropy, metrics=['accuracy'])import datetimestart_time = datetime.datetime.now()model.fit(x=x_train, y=y_train, batch_size=batch_size, epochs=num_epochs)end_time = datetime.datetime.now()time_cost = end_time - start_timeprint (\"time_cost = \", time_cost) 总体就是这样了，具体实现我没细说，毕竟机器学习里面的神经网络要求具体实现的，比这个调用详细地多，但是不得不说，机器学习神经网络的快速发展，和这些方便调用的库是离不开关系的，确实是很大地降低了门槛。 下面就是试试测试集 测试123456789101112131415161718192021print (x_test[image_index].shape)plt.imshow(x_test[image_index].reshape(32, 32),cmap='Greys')plt.show()pred = model.predict(x_test[image_index].reshape(1, 32, 32, 1))print(pred.argmax())#模型保存model.save('lenet_model.h5')# 评估指标print(model.evaluate(x_test, y_test)) # loss value &amp; metrics values# 预测image_index = 4444print (x_test[image_index].shape)plt.imshow(x_test[image_index].reshape(32, 32),cmap='Greys')plt.show()pred = model.predict(x_test[image_index].reshape(1, 32, 32, 1))print(pred.argmax()) 准确率还是十分高的，这次就到这里了，再找个经典例子练练手就填以太坊的坑。 初一以为假期还有15天，初四发现还有20天，初十发现还有30天，马萨卡，这就是时间线的变动么orz","path":"2020/02/05/tensorflow nmist库手写数字识别/","date":"02-05","excerpt":"","tags":[]},{"title":"tensorflow在windows下的安装（无anaconda）","text":"tensorflow在windows下的安装（无anaconda）其实早就想入tensorflow的坑了，正好上个学期学了机器学习，然后学校因为病毒特么推迟到一周开学（我这个寒假是要比暑假还长咯），我就开个坑，刨个坟。 首先，我是在无anaconda的情况下安装tensorflow的。网上的tensorflow大部分是在anaconda的环境下安装的，但是我用原生的python用惯了，所以还是打算继续在这个基础上加库 以前的tensorflow只支持python3.5或python2.7，现在tensorflow2.0以后就可以支持3.6+，所以我安装在我目前常用的python3.7下。 下载首先要在python官网PyPi下载tensorflow（我的版本是2.1.0），如果是cpu版的（训练偏慢），需要下载tensorflow-cpu，注意了，python是什么版本的就下载-cp版本号，其他软件道理也一样，如，我用python3.7，就是-cp37 当然，如果能科学上网（我就是亏在用插件科学上网），那么直接用pip下载应该也是可以的（或者是找到镜像网站），不过python官网下载速度很赞了 安装打开cmd到下载目录，加载下载的wheel文件 1pip install --upgrade wheel文件名 如果是cpu的那么就到此为止了，但是GPU还不行，以下是安装英伟达GPU加速的库 CUDA Toolkit安装首先得有个GPU，然后就是GPU得支持CUDA cuda Toolkit要到Nvidia的官网去下，注意了，可以选择先运行一下tensorflow，它会找不到一个cudaXXX.dll，像我是101.dll，那么CUDA就要下载10.1的版本，能下载到完全对应版本是最好，但是如果没有下到，那就下载最近的版本，正常安装就可以了 cuDnn库下载同样是Nvidia提供的接口库，用于tensorflow等需要GPU渲染或是加速的软件或工具使用。简单填写一些问题就可以下载了 cuDnn库加载在CUDA Toolkit安装完成后，就是之前的cuDnn库的加载了。直接把文件拷贝到CUDA Toolkit对应的文件夹下就可以了 其他在一切完成后，发现环境变量有点问题，在CUDA_PATH中加入/bin和/lib/x64，最好重启一下，让环境变量能加载出来 如果之前下载的CUDA Toolkit和tensorflow的不一样，就会报出could not load dynamic library ‘cudart64_XXX’，在CUDA安装路径找到cudart64_XXY，改为未找到的XXX基本就可以了，也可以去网上找到对应的XXX文件放进去，现在就可以看到加载成功了 好的，咸鱼安装方法就记录到这里，下一期就做个python下tf的nmist小项目康康= = 咸鱼的假哦，怎么这么长啊 :-(","path":"2020/02/04/tensorflow在windows下的安装（无anaconda）/","date":"02-04","excerpt":"","tags":[]},{"title":"leetcode - Pow(x, n)","text":"leetcode: Pow(x, n)实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 输入: 2.00000, 10输出: 1024.00000示例 2: 输入: 2.10000, 3输出: 9.26100示例 3: 输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 首先，我们就试试暴力破解 出错了，卡在了测试样例0.00001 2147483647 12345678910111213141516class Solution(object): def myPow(self, x, n): \"\"\" :type x: float :type n: int :rtype: float \"\"\" if n &lt; 0: x = 1 / x n = -n temp = 1 for i in range(n): temp = temp * x return temp 为什么，内存错误（溢出），这个数字太小了，想想溢出才是正常的吧 12def myPow(self, x: float, n: int) -&gt; float: return x**n 差点忘了python可以直接求幂啊。 然后看看题解的快速幂方法，我记得洛谷好像空耳为卡速米 12345678910111213141516171819202122class Solution &#123;public: double fastPow(double x, long long n) &#123; if (n == 0) &#123; return 1.0; &#125; double half = fastPow(x, n / 2); if (n % 2 == 0) &#123; return half * half; &#125; else &#123; return half * half * x; &#125; &#125; double myPow(double x, int n) &#123; long long N = n; if (N &lt; 0) &#123; x = 1 / x; N = -N; &#125; return fastPow(x, N); &#125;&#125;; 通过不断分解幂达到快速计算幂的效果 放假啦，回家啦，不想回家啊艹 想去实习下学期又有课，想做项目又没有路子，脑壳疼，还是再闲两天吧，学学日语，看看要不要考个教师资格证，当老师其实也挺好。压力不大还能余一点时间学代码。 不想这么多了，收拾收拾回家了= =","path":"2020/01/06/leetcode-Pow(x,n)/","date":"01-06","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"RSS&RSSHub学习-操作-感悟","text":"RSS&amp;RSSHub学习-操作-感悟先说说RSS吧RSS我是从diygod大佬博客里看到的 看概念一开始完全懵逼，但是下了一个RSS阅读器后就大概知道是个什么东西了，老实说，这个十分实用，对于我这种长期坐在电脑前的死宅来说尤其如此。它省了我很多去各个网站浏览的时间–因为它把所有网站集成了。 这个怎么实现呢，首先是通过RSS阅读器解析一个网站的RSS，通过RSS获取这个网站的信息。而如何获取信息的方式，就全部写在RSS里，但是每个网站内容，格式，形式不一样，所以RSS也不一样，就是说，每个RSS都要单独编写。 所以在RSS出来后就火了一阵子，但是问题来了。首先不一定有人做这个网站的RSS，做了也可能找不到，找到了也可能因为页面更新换代用不了，另外RSS 不利于网站方的广告投放、隐私搜集、用户存留等商业行为。这就是RSS难以兴起的原因= =。 RSSHUB是什么RSSHub是diygod发起的一个开源项目，目的是简化和标准RSS的制作流程，让更多的人可以参与到RSS的制作里面来。当然现在不止这么一个项目可以做出RSS地址，但是目前来看应该是相对比较完善的。 通过RSSHub做一个RSS一开始是打算加入项目做一个contributor的，发动要素察觉，发现是nodejs（没学过），发现310个参与者，发现项目大小，好的，你的痛苦实力在我之上，我就做个RSS自娱自乐学学nodejs算了（流下了没能力的泪水） 首先我之前说过RSS实质上是写了一个爬虫，爬取了网页数据，所以我这次要写的就是nodejs爬虫。这次爬的就是中南大学官网的中南要闻。 由于nodejs集成了一些其他东西，所以我先写一个纯nodejs版本的爬虫 123456789101112131415161718const http = require(\"http\"); const cheerio = require(\"cheerio\");const baseurl = 'http://news.csu.edu.cn/info/1002/143733.htm'; //官网上的内嵌页面http.get(baseurl, function(res)&#123; var html = ''; res.on('data', function(data)&#123; html += data; //爬取整个页面 &#125;); res.on('end', function()&#123; var $ = cheerio.load(html); $('.otherTme').each(function(i, e)&#123; //选择器选到标题 console.log($(e).text()); &#125;); &#125;);&#125;).on('error', function() &#123; console.log('获取数据出错！');&#125;); 这个就简单爬取了一下标题（实际上我打算就爬个标题，爬个链接href就好了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const got = require('@/utils/got');const cheerio = require('cheerio');module.exports = async (ctx) =&gt; &#123; const baseurl = 'http://www.csu.edu.cn/'; const url = 'http://www.csu.edu.cn/yw.htm'; const response = await got(&#123; method: 'get', url: url, &#125;); const $ = cheerio.load(response.data); const list = $('a'); const count = []; for(let i = 0 ; i &lt; Math.min(list.length, 6); i++) &#123; count.push(i) &#125; const out = await Promise.all( count.map(async (i) =&gt; &#123; const each = $(list[i]); const storyLink = each.attr('href'); const item = &#123; title: each.attr('title'), link: storyLink, &#125;; const key = item.link; const responseAuthor = await got(&#123; method: 'get', url: key, &#125;); /* const $ = cheerio.load(responseAuthor.data); $1('.otherTme').each(function(i, e)&#123; item.discription = `作者：$1&#123;$1(e).first().text()&#125;&lt;br&gt;描述：测试`; &#125;); */ return Promise.resolve(item); &#125;) ); ctx.state.data = &#123; title: '中南要闻', link: 'http://www.csu.edu.cn/yw.htm', item: out, &#125;&#125;; 大概就是这样吧，本地部署效果是ok的，就是没有上传到github上去部署，实在是太菜了= =。 再开一个坑，爬取校内通知，但是这个的cookie在请求头中，让人头大，目前还没能做出来，那天想起来再填坑吧","path":"2020/01/05/RSS&RSSHub学习-操作-感悟/","date":"01-05","excerpt":"","tags":[]},{"title":"hexo插入Aplayer插件","text":"hexo插入Aplayer插件Aplayer是diygod大佬开始的一个开源项目，用来给网页加载播放器，我是大概一年前发现的这个项目，当时就加在了老博客上，但是当我把博客转到hexo后直接用的hexo的theme，就没有在意hexo的实现，所以便没有加入，然后发现了这个Aplayer插件= = 开发与维护者是grzhan https://github.com/MoePlayer/hexo-tag-aplayer 下面是一个效果演示 var ap = new APlayer({ element: document.getElementById(\"aplayer-ejmXIaor\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"LET'S GO GET U!\", author: \"香菜\", url: \"../hexo插入Aplayer插件/LET'S GO GET U!.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 我觉得很ok，什么时候才能成为大佬啊，熬不住了啊: - ( 然后看看配置和加载办法（当然上面的链接下面有开发文档） 配置和加载办法首先要安装hexo-tag-aplayer，在博客大文件夹下运行 1npm install --save hexo-tag-aplayer 然后用 1hexo new &quot;name&quot; 新建一个markdown文档 在文档下写入 1&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125; 如果是多个，可以用播放器 123456789101112131415161718192021222324252627&#123;% aplayerlist %&#125;&#123; &quot;narrow&quot;: false, // （可选）播放器袖珍风格 &quot;autoplay&quot;: true, // （可选) 自动播放，移动端浏览器暂时不支持此功能 &quot;mode&quot;: &quot;random&quot;, // （可选）曲目循环类型，有 &apos;random&apos;（随机播放）, &apos;single&apos; (单曲播放), &apos;circulation&apos; (循环播放), &apos;order&apos; (列表播放)， 默认：&apos;circulation&apos; &quot;showlrc&quot;: 3, // （可选）歌词显示配置项，可选项有：1,2,3 &quot;mutex&quot;: true, // （可选）该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 &quot;theme&quot;: &quot;#e6d0b2&quot;, // （可选）播放器风格色彩设置，默认：#b7daff &quot;preload&quot;: &quot;metadata&quot;, // （可选）音乐文件预载入模式，可选项： &apos;none&apos; &apos;metadata&apos; &apos;auto&apos;, 默认: &apos;auto&apos; &quot;listmaxheight&quot;: &quot;513px&quot;, // (可选) 该播放列表的最大长度 &quot;music&quot;: [ &#123; &quot;title&quot;: &quot;CoCo&quot;, &quot;author&quot;: &quot;Jeff Williams&quot;, &quot;url&quot;: &quot;caffeine.mp3&quot;, &quot;pic&quot;: &quot;caffeine.jpeg&quot;, &quot;lrc&quot;: &quot;caffeine.txt&quot; &#125;, &#123; &quot;title&quot;: &quot;アイロニ&quot;, &quot;author&quot;: &quot;鹿乃&quot;, &quot;url&quot;: &quot;irony.mp3&quot;, &quot;pic&quot;: &quot;irony.jpg&quot; &#125; ]&#125;&#123;% endaplayerlist %&#125; 但是播放器我这里调用会有错误，可能是版本问题吧，暂时不太想继续搞。下次想个办法把live2d看板娘给插入到hexo里来（本来就很难加载了，我觉得我是在作死= =）","path":"2020/01/01/hexo插入Aplayer插件/","date":"01-01","excerpt":"","tags":[]},{"title":"oracle cursor生成学生号","text":"oracle cursor生成学生号由前面做过的实验，学号的规格是这样的ABCD17EFGH共10位，AB表示学院 CD表示专业 17表示年级 EF表示班级 GH表示班里的序号 班级序号是连续的，班内学号是连续的 创建一个学院专业信息表要自动生成学生号，那么先把那些学院 专业 人数 班级数先输入是十分合情又合理的事情= =，所以这些信息我们得先建个表 123456789101112create table sch_J314( college varchar(4), major varchar(4), class_num int, stud_num int);insert into sch_J314 values('09', '02', 7, 200);insert into sch_J314 values('02', '09', 4, 100);insert into sch_J314 values('03', '03', 5, 150);insert into sch_J314 values('09', '05', 4, 102);insert into sch_J314 values('03', '04', 6, 170);select * from sch_J314; 既然要自动生成学号那还要一个保存生成的学号的表（本来可以用stud_J314，但是想想还要改约束，还是新建吧） 123create table sno_J314( sno varchar(20) primary key); 下一步就是创建这么一个过程来把生成的学号存入sno_J314 1234567891011121314151617181920212223242526272829303132create or replace procedure P_sno_J314as cursor num is select * from sch_J314; college varchar(4); major varchar(4); class int; stud int; each_stud int;begin for a in num loop college := a.college; major := a.major; class := a.class_num; stud := a.stud_num; each_stud := stud/class; if each_stud * class &gt; stud then each_stud := each_stud - 1; end if; for i in 1..class loop for j in 1..each_stud loop insert into sno_J314 values(college||major||&apos;17&apos;||TO_CHAR(i,&apos;FM09&apos;)||TO_CHAR(j,&apos;FM09&apos;)); end loop; end loop; for i in 1..stud - each_stud * class loop insert into sno_J314 values(college||major||&apos;17&apos;||TO_CHAR(i,&apos;FM09&apos;)||TO_CHAR(stud / class + 1,&apos;FM09&apos;)); end loop; end loop;end P_sno_J314;./exec P_sno_J314; 中间发现一个问题，我默认是像C/C++一样int类型相除取整，结果本应有722个结果变成了725个，查阅资料后才知道是四舍五入","path":"2019/12/21/cursor生成学生号/","date":"12-21","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://nomalbuthappy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库实验四","text":"数据库实验四实验四要求:1．建立对应3GB大小的外部文件的tablespace tabspace_???? 2．重建major_????与stud_????，指定存于建立的tabspace_????中， 3．重新产生样本值，包括千万级数据的stud表，看是否有性能上的提升。 4．用EXP导出数据与IMP导入数据，请作多种尝试，直到成功！ 5．尝试对系统表空间user及自定义表空间tabspace_????进行备份与恢复。 6．登录DBA用户system，通过cat字典入口，找到以DBA_开头的相关数据字典，并且每个对象显示5条记录（SQL生成SQL）。 7．通过查找自己用户下的触发器字典，生成代码将所有触发器的状态改为disable并执行。再生成代码，将状态为disable的触发器的状态改为enable，并执行 1 首先，先建立一个表空间12create tablespace tabspace_J314 datafile 'D:\\tools\\oracle\\oradata\\orcl/four.dbf' size 3072m;--这里前面的D:\\tools\\oracle\\oradata\\orcl为oracle安装路径 2 重建两个表1234567891011121314151617181920212223242526272829303132333435drop table major_J314;create table major_J314 ( MajorNo varchar2(20) primary key, MNAME varchar2(50), loc varchar2(20), mdean varchar2(20), constraint mj_loc check (loc IN ('主校区', '南校区', '新校区', '铁道校区', '湘雅校区')))tablespace tabspace_J314;drop table stud_J314;create table stud_J314 ( SNO varchar2(20) primary key, SNAME varchar2(20), SEX varchar2(5), TEL varchar2(20), E_MAIL varchar2(20), birthday date, MNO varchar2(20), MajorNo varchar2(20), constraint sj_sex check (sex IN ('男','女','其他')), constraint sj_E_MAIL check (REGEXP_LIKE (E_MAIL,'[a-zA-Z0-9._%-]+@[a-zA-Z0-9._%-]+\\.[a-zA-Z]&#123;2,4&#125;')))tablespace tabspace_J314;drop table student_J314;create table student_J314( sno char(10) primary key, name varchar2(10), sex varchar2(2), tel varchar2(20), e_mail varchar2(20), birthday date)tablespace tabspace_J314; 3 重新生成样本值123456789101112131415161718192021222324252627282930313233343536373839insert into major_J314 values(&apos;02&apos;, &apos;计算机科学与技术&apos;, &apos;南校区&apos;, &apos;张祖平&apos;);insert into major_J314 values(&apos;03&apos;, &apos;物联网工程&apos;, &apos;南校区&apos;, &apos;张祖平&apos;);insert into major_J314 values(&apos;04&apos;, &apos;数据科学与大数据技术&apos;, &apos;南校区&apos;, &apos;张祖平&apos;);insert into stud_J314 values (&apos;0902170314&apos;, &apos;颜灿&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0902170314&apos;, &apos;02&apos;);insert into stud_J314 values (&apos;0903170314&apos;, &apos;a&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0902170314&apos;, &apos;03&apos;);insert into stud_J314 values (&apos;0904170314&apos;, &apos;b&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0904170314&apos;, &apos;04&apos;);--非班长学生insert into stud_J314 values (&apos;0902170101&apos;, &apos;1&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0902170314&apos;, &apos;02&apos;);insert into stud_J314 values (&apos;0902170102&apos;, &apos;2&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0902170314&apos;, &apos;02&apos;);insert into stud_J314 values (&apos;0902170103&apos;, &apos;3&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0902170314&apos;, &apos;02&apos;);insert into stud_J314 values (&apos;0902170104&apos;, &apos;4&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0902170314&apos;, &apos;02&apos;);insert into stud_J314 values (&apos;0902170105&apos;, &apos;5&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0902170314&apos;, &apos;02&apos;);insert into stud_J314 values (&apos;0902170106&apos;, &apos;6&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0902170314&apos;, &apos;02&apos;);insert into stud_J314 values (&apos;0902170107&apos;, &apos;7&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0902170314&apos;, &apos;02&apos;);insert into stud_J314 values (&apos;0902170108&apos;, &apos;8&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0902170314&apos;, &apos;02&apos;);insert into stud_J314 values (&apos;0902170109&apos;, &apos;9&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0902170314&apos;, &apos;02&apos;);insert into stud_J314 values (&apos;0903170101&apos;, &apos;1&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0903170314&apos;, &apos;03&apos;);insert into stud_J314 values (&apos;0903170102&apos;, &apos;2&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0903170314&apos;, &apos;03&apos;);insert into stud_J314 values (&apos;0903170103&apos;, &apos;3&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0903170314&apos;, &apos;03&apos;);insert into stud_J314 values (&apos;0903170104&apos;, &apos;4&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0903170314&apos;, &apos;03&apos;);insert into stud_J314 values (&apos;0903170105&apos;, &apos;5&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0903170314&apos;, &apos;03&apos;);insert into stud_J314 values (&apos;0903170106&apos;, &apos;6&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0903170314&apos;, &apos;03&apos;);insert into stud_J314 values (&apos;0903170107&apos;, &apos;7&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0903170314&apos;, &apos;03&apos;);insert into stud_J314 values (&apos;0903170108&apos;, &apos;8&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0903170314&apos;, &apos;03&apos;);insert into stud_J314 values (&apos;0903170109&apos;, &apos;9&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0903170314&apos;, &apos;03&apos;);insert into stud_J314 values (&apos;0904170101&apos;, &apos;1&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0904170314&apos;, &apos;04&apos;);insert into stud_J314 values (&apos;0904170102&apos;, &apos;2&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0904170314&apos;, &apos;04&apos;);insert into stud_J314 values (&apos;0904170103&apos;, &apos;3&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0904170314&apos;, &apos;04&apos;);insert into stud_J314 values (&apos;0904170104&apos;, &apos;4&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0904170314&apos;, &apos;04&apos;);insert into stud_J314 values (&apos;0904170105&apos;, &apos;5&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0904170314&apos;, &apos;04&apos;);insert into stud_J314 values (&apos;0904170106&apos;, &apos;6&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0904170314&apos;, &apos;04&apos;);insert into stud_J314 values (&apos;0904170107&apos;, &apos;7&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0904170314&apos;, &apos;04&apos;);insert into stud_J314 values (&apos;0904170108&apos;, &apos;8&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0904170314&apos;, &apos;04&apos;);insert into stud_J314 values (&apos;0904170109&apos;, &apos;9&apos;, &apos;男&apos;, &apos;1&apos;, &apos;123@qq.com&apos;, to_date(&apos;20001010&apos;, &apos;YYYYMMDD&apos;), &apos;0904170314&apos;, &apos;04&apos;);exec P_student_J314; 4 用EXP和IMP导入数据1234567891011exp U_J314/YcYyj1234 file=D:\\oracle\\test1.dmp tables=major_J314exp U_J314/YcYyj1234 file=D:\\oracle\\test2.dmp tables=stud_J314exp U_J314/YcYyj1234 file=D:\\oracle\\test3.dmp tables=student_J314exp U_J314/YcYyj1234 file=D:\\oracle\\test4.dmp tables=(stud_J314,major_J314,student_J314)drop table major_J314;drop table stud_J314;drop table student_J314;imp U_J314/YcYyj1234 file=D:\\oracle\\test1.dmp tables=major_J314imp U_J314/YcYyj1234 file=D:\\oracle\\test2.dmp tables=stud_J314imp U_J314/YcYyj1234 file=D:\\oracle\\test3.dmp tables=student_J314imp U_J314/YcYyj1234 file=D:\\oracle\\test4.dmp tables=(major_J314,stud_J314,student_J314) 速度上是快了不少，大概2分钟插入完成，之前是12分钟多 5 对系统表空间与自定义表空间备份维护12345678910111213141516171819202122--这里就用RMAN,但是在备份时发现了错误，在noarchivelog状态无法备份，所以需要重启数据库改为archievelog模式alter system archieve log start;shutdown immediate;startup mount;alter database archivelog;shutdown immediate;startup;--下一步就是备份数据库了backup database format 'D:/tools/oracle/oradata/backup/%d_bak_%t';backup tablespace system;backup tablespace tabspace_J314;--这个地方又出现一个问题，备份空间不足，tabspace_J314的大小是3G，所以我们需要给他一个大一点的空间alter system set db_recovery_show parameter db_recovery_file_dest--系统空间不能脱机，所以我就恢复一下tabspace_J314--发现一个问题是无法获得exclusive入队，查资料后发现是没改为mount状态startup mount;run&#123; restore tablespace system; recover tablespace system;&#125; 6 登陆12345spool D:\\blog\\table_name.txtconn system/YcYyj1234 as sysdbadesc cat --查看字典名称列名select 'select * from '||table_name||' where rownum&lt;=5;' from cat where table_name like 'DBA_%';spool off 7 修改触发器123456789select trigger_name from user_triggers; --查看有哪些触发器spool D:\\blog\\disable.txtselect 'alter trigger '||trigger_name||' disable;' from user_triggers;spool off;spool D:\\blog\\enable.txtselect 'alter trigger '||trigger_name||' enable;' from user_triggers;spool off;","path":"2019/12/09/数据库实验四/","date":"12-09","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://nomalbuthappy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库实验五","text":"数据库实验五实验五要求:1．创建一个PROFILE文件pTester，设置锁定用户的登录失败次数为3次，会话的总计连接时间60分钟，口令可用天数30天。 2．创建一个新用户Tester，密码为Tester123，缺省表空间是tabspace_????。在tabspace_????表空间中可以使用50M空间，指定环境资源文件为pTester。 3．将角色RESOURCE指派给用户Tester。 4．用EXP和IMP工具将之前创建的major_????表导入到Tester用户下。 5．利用PL/SQL语言，以major_????表为例，编写一个存储过程实现针对单张表的逻辑数据导出功能，要求将给定表的数据转换成SQL语言的Insert语句，表的结构转换成SQL语言的Create Table语句，并保存在文件中。该过程以要导出的表名和保存SQL语句的文件名为参数。 1 创建一个profile文件，限失败三次，连接时间60分钟，口令可用30天这个把要求已经限制死了，直接创建就好了 1create profile pTester limit FAILED_LOGIN_ATTEMPTS 3 CONNECT_TIME 60 PASSWORD_LOCK_TIME 30; 2 创建用户并指定资源文件12select profile, resource_name, limit from dba_profiles order by profile; --查看资源文件和限制create user Tester identified by Tester123 default tablespace tabspace_J314 quota 50m on tabspace_J314 profile pTester; 3 把角色资源指派给Tester1grant resource to Tester; 4用EXP与IMP把之前创建的表导入到Tester下123--先用exp把U_J314下的表导出exp U_J314/YcYyj1234 tables = (major_J314) file = D:\\oracle\\test5.dmpimp Tester/Tester123 file = D:\\oracle\\test5.dmp tables=(major_J314) 5用PL/SQL写一个单张表输出的过程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677![p1](D:\\blog\\数据库实验五\\p1.JPG)create table major_J314 ( MajorNo varchar(20) primary key, MNAME varchar(50), loc varchar(20), mdean varchar(20), constraint mj_loc check (loc IN (&apos;主校区&apos;, &apos;南校区&apos;, &apos;新校区&apos;, &apos;铁道校区&apos;, &apos;湘雅校区&apos;)));create or replace procedure P_table_J314( tname in char, fname in char)isl_file utl_file.file_type;v_sql varchar2(100);v_count number;begin l_file := utl_file.fopen(&apos;FILEPATH&apos;, fname, &apos;W&apos;); utl_file.put_line(l_file,&apos;create table &apos;||tname); utl_file.put_line(l_file,&apos;(&apos;); for name in (select column_name, data_type from user_tab_columns where table_name = upper(tname))loop utl_file.put_line(l_file, &apos; &apos;||name.column_name||&apos; &apos;||name.data_type||&apos; &apos;); end loop; utl_file.put_line(l_file,&apos;);&apos;); utl_file.fclose(l_file);end P_table_J314;./exec P_table_J314(&apos;major_J314&apos;, &apos;123.txt&apos;) execute immediate &apos;select * from &apos;||tname into v_sql for a in (v_sql)loop utl_file.put_line(l_file,&apos;insert into &apos;||tname||&apos; values(&apos;); end loop;v_sql:=&apos;select * from &apos; || tname; execute immediate v_sql into v_count; utl_file.put_line(l_file,v_count); utl_file.put_line(l_file,&apos;)&apos;);for a in (select * from major_J314)loop end loop;for a in (select * from major_J314)loop utl_file.put_line(l_file,&apos;insert into &apos;||tname||&apos; values(&apos;); for name in (select column_name from user_tab_columns where table_name = upper(tname))loop v_sql := name.column_name; utl_file.put_line(l_file,a.v_sql); end loop; utl_file.put_line(l_file,&apos;)&apos;); end loop;utl_file.put_line(l_file,&apos;MajorNo varchar(20) primary key,MNAME varchar(50),loc varchar(20),mdean varchar(20)&apos;);utl_file.put_line(l_file, select &apos;insert into &apos;||tname||&apos; values(&apos;||&apos;)&apos;);select dbms_metadata.get_ddl(&apos;TABLE&apos;,&apos;major_J314&apos;,&apos;Tester&apos;) from dual; utl_file.put_line(l_file, SELECT DBMS_METADATA.GET_DDL(&apos;TABLE&apos;,&apos;DEPT&apos;,&apos;SCOTT&apos;) FROM DUAL;)select * from cols WHERE TABLE_name=upper(&apos;table_name&apos;);","path":"2019/12/09/数据库实验五/","date":"12-09","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://nomalbuthappy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库实验 - oracle","text":"数据库实验三吐血= =过几天生日家里要来人，还有这么多实验作业，惹不起惹不起 实验三要求:1.以常用“名字大全”与“百家姓”数据集为基础，生成不小于1千万条stud记录，要求，姓名的重复率不超过10%，学号以ABCD17EFGH为格式模板，即其中17是固定的，AB为从01到80，CD为从01到90，EF为01到50，GH为01到32；性别中，男、女占比为99%到99.5%。TEL与E-mail不作要求，但不能全空。Birthday要求从‘19940101’到‘19990731’分布。要求记录ORACLE数据文件的大小变化。（需要编制过程） 2．分别测试stud有主键与没有主键情形下生成记录的时间。 3．建立基于sname的索引index_name，测试建立的时间与建立索引前后查询某一姓名及某一姓的时间长度。 4．测试索引index_name建立前后，分姓（简单地理解为姓名的第1，2位）的记录数统计时间。 5．按学号首位建立10个分区分别为part_0到part_9，测试建立分区前后分首位统计人数与分专业（EF位）统计人数的时间差别。 要求一需要1千万以上的stud记录并有各种各样的要求，那么就需要先编造这一千万条数据，上次做的时候用了常用姓 X 常用字 X 常用字的笛卡儿积，那么就出了一个问题，常用字的数据集合是3000，那么名部分的 3000 X 3000 = 0.9kw，我们一共需要1kw数据，而第一个名字就占了0.9kw，这样明显不太行，所以我们需要另一个合理的编造数据方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133--先建立学生表用于导入数据drop table student_J314;create table student_J314( sno char(10) primary key, name varchar(10), sex varchar(2), tel varchar(20), e_mail varchar(20), birthday date);set TIMING on; --康康等下的运行花了多少时间--导入数据drop table first_name;create table first_name( fname varchar(5));drop table second_name;create table second_name( sname varchar(5));drop table name;create table name( name varchar(10));--由于数据源在excel里，我们需要先导出来，求不出错一个一个来--first_nameload datainfile 'd:\\blog\\first.csv'append into table first_name fields terminated by ','trailing nullcols(fname)&gt; sqlldr userid = U_J314/YcYyj1234 control = d:\\blog\\load.ctl--415条记录--second_nameload datainfile 'd:\\blog\\second.csv'append into table second_name fields terminated by ','trailing nullcols(sname)&gt; sqlldr userid = U_J314/YcYyj1234 control = d:\\blog\\second.ctl--3177条记录--姓和名都有了现在就需要来随机组合成名字了（编数据都要编得这么麻烦，没法吐槽了）--我创建一个生成随机名字的过程，为了防止出现某个姓的名字过多，这次我就用111 * 111 * 999的方法生成不少于一千万条数据(实际上我是生成了11111111条数据)drop procedure P_name_J314;create or replace procedure P_name_J314is cnt PLS_INTEGER:=1; first varchar(5); second varchar(5); third varchar(5); maxl PLS_INTEGER:=11111111;begin FOR a in (select * from first_name where rownum&lt;=100) loop exit when cnt &gt; maxl; first:=a.fname; FOR b in (select * from second_name where rownum&lt;=101) loop exit when cnt &gt; maxl; second:=b.sname; FOR c in (select * from second_name where rownum&lt;=1001) loop exit when cnt &gt; maxl; third := c.sname; insert into name values (first||second||third); cnt := cnt + 1; END LOOP; END LOOP; END LOOP;END;./--现在我们来建立插入数据的过程drop procedure P_student_J314;create or replace procedure P_student_J314is cnt PLS_INTEGER:=1; msno varchar(10); mname varchar(10); msex varchar(2); mtel varchar(20); me_mail varchar(20); mbirthday date; rsex PLS_INTEGER; rdate PLS_INTEGER; maxl PLS_INTEGER:=10001111; dif PLS_INTEGER; cursor c_name is (select name from name);begin dif := ROUND(TO_NUMBER(to_date('19990731', 'YYYYMMDD') - to_date('19940101', 'YYYYMMDD'))); OPEN c_name; for ab in 1..80 LOOP EXIT WHEN cnt &gt; maxl; for cd in 1..90 LOOP EXIT WHEN cnt &gt; maxl; for ef in 1..50 LOOP EXIT WHEN cnt &gt; maxl; for gh in 1..32 LOOP EXIT WHEN cnt &gt; maxl; FETCH c_name INTO mname; rsex := DBMS_RANDOM.VALUE(1,1000); --随机性别，并把比例分好 if rsex &lt;= 496 then msex := '男'; elsif rsex &lt;= 993 then msex := '女'; else msex := '无'; end if; rdate := DBMS_RANDOM.VALUE(0,dif); --通过时间差来随机日期 mbirthday := to_date('19940101', 'YYYYMMDD') + rdate; insert into student_J314 values(TO_CHAR(ab,'FM09')||TO_CHAR(cd,'FM09')||'17'||TO_CHAR(ef,'FM09')||TO_CHAR(gh,'FM09'), mname, msex, '123456', '321654', mbirthday); cnt := cnt + 1; END LOOP; END LOOP; END LOOP; END LOOP;END;./--然后，我们先查看数据文件的大小，这一句是查看数据文件路径select file_name , tablespace_name from dba_data_files;--下一步就是插入exec P_student_J314;--时间空间变化如下 2 要求有主键与没主键生成记录的时间比较那就是再插入一次没主键的咯，有主键要判断主键约束，所以按道理来说没主键会快一些 下面是结果，果然是没主键快一些 3 要求建立基于sname的索引，并比较建立前后既然要比较建立索引的前后，所以我先把建立前的时间长度做好 12345678910select * from student_J314 where sno='0302170101'; --可以看到这个人叫云夫步select count(*) from student_J314 where name='云夫步'; select count(*) from student_J314 where name like '云%';select count(*) from student_J314 where name like '云夫%';create index index_name on student_J314(name);select count(*) from student_J314 where name='云夫步'; select count(*) from student_J314 where name like '云%';select count(*) from student_J314 where name like '云夫%';--运行过程及时间如下，显然建立索引后速度快得多 4 分区0-9，分首位统计与分专业统计的差别完蛋，现在要分区，就要把之前建好的表删掉重建，早知道就把之前的数据分别存好了 那么就从删表与重建开始 123456789101112131415161718192021222324delete from student_J314;drop table student_J314;create table student_J314( sno char(10) primary key, name varchar(10), sex varchar(2), tel varchar(20), e_mail varchar(20), birthday date)partition by range(sno)( partition part_0 values less than ('1000000000'), partition part_1 values less than ('2000000000'), partition part_2 values less than ('3000000000'), partition part_3 values less than ('4000000000'), partition part_4 values less than ('5000000000'), partition part_5 values less than ('6000000000'), partition part_6 values less than ('7000000000'), partition part_7 values less than ('8000000000'), partition part_8 values less than ('9000000000'), partition part_9 values less than ('9999999999'));exec P_student_J314;select count(*) from student_J314 partition(part_3) where sno like '3%';select count(*) from student_J314 where sno like '______01%';","path":"2019/12/09/数据库实验三（改）/","date":"12-09","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://nomalbuthappy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"leetcode - 最接近的三数之和","text":"leetcode: 最接近的三数之和给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 12例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 这题在我看来和上一个三数之和差不多，算是一个衍生版吧，那就沿用上题的思路来改进吧 我们先随便写个用不排序的遍历试试 1234567891011121314151617181920class Solution(object): def threeSumClosest(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" rint = 9999999 rint1 = 0 for i in range(len(nums)): for j in range(i+1, len(nums)): for k in range(j+1, len(nums)): a = nums[i] + nums[j] + nums[k] - target if a &gt;= 0 and a &lt;= rint: rint = a rint1 = a + target elif a &lt; 0 and -a &lt;= rint: rint = -a rint1 = a + target return rint1 不出我们所料，他果然超时了，倒在了第67个用例上，然后我们试着排一下序 123456789101112131415161718192021222324252627282930class Solution(object): def threeSumClosest(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" rint = 9999999 rint1 = 0 nums.sort() for i in range(len(nums)): if i == 0 or nums[i] &gt; nums[i-1]: if nums[i] - rint &gt; target and nums[i] &gt; 0: break for j in range(i+1, len(nums)): if j == i+1 or nums[j] &gt; nums[j-1]: if nums[i] + nums[j] - rint &gt; target and nums[j] &gt; 0: break for k in range(j+1, len(nums)): if k == j+1 or nums[k] &gt; nums[k-1]: if nums[i] + nums[j] + nums[k] - rint &gt; target and nums[k] &gt; 0: break a = nums[i] + nums[j] + nums[k] - target if a &gt;= 0 and a &lt;= rint: rint = a rint1 = a + target elif a &lt; 0 and -a &lt;= rint: rint = -a rint1 = a + target return rint1 好的倒在了第108个用例上，他尽力了= =，我们再用双指针法试试 1234567891011121314151617181920212223242526272829303132class Solution(object): def threeSumClosest(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" rint = 9999999 rint1 = 0 nums.sort() for i in range(len(nums)): if i == 0 or nums[i] &gt; nums[i-1]: l = i + 1 r = len(nums) - 1 while l &lt; r: s = nums[i] + nums[l] + nums[r] a = s - target if a &lt; 0: l += 1 if -a &lt; rint: rint = -a rint1 = s elif a &gt; 0: r -= 1 if a &lt; rint: rint = a rint1 = s else: rint = 0 rint1 = target break; return rint1 好的，双指针大法真好用，一次就过了。 这周还要补数据库图形学软工毛概，啊啊啊啊啊啊啊啊，有毒啊，还我周末啊","path":"2019/12/06/leetcode-最接近的三数之和/","date":"12-06","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"异色初音","text":"TAITO 异色初音 夏服 景办 开箱美滋滋，本来是抱着玩玩的想法参加的会员购抽奖，然后就中景办了= =，对，没错，非酋洗脸了（也可能是手办买多了，算法推了一个景办可怜可怜我），先康康拆箱效果吧 ps: 这是盒照 ps：里面的所有组件 ps：组装完成！老婆真好看 (｡・`ω´･) ps：老婆侧颜(･`ω´・｡) ps：拉近角度（景办还是做工不必手办，但是TAITO的造型太好了，瑕不掩瑜啊） 好看，想。。。没，没想啥 呆在我的架子上吧(:3 」∠) var ap = new APlayer({ element: document.getElementById(\"aplayer-MszEJDSD\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"你好！\", author: \"MusikM\", url: \"../异色初音/初音ミク,MusikM - 你好.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","path":"2019/12/02/异色初音/","date":"12-02","excerpt":"","tags":[]},{"title":"leetcode - 三数之和2","text":"leetcode: 三数之和（补充：昨天搞考试去了）给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] n个整数找到所有的a + b + c = 0，二话不说，我们先遍历试试 123456789101112131415161718192021class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums = sorted(nums) rnums = [] for i in range(len(nums)): for j in range(i+1, len(nums)): for k in range(j+1, len(nums)): if nums[i] + nums[j] + nums[k] == 0: flag = 1 for a in rnums: if a == [nums[i], nums[j], nums[k]]: flag = 0 break if flag: rnums.append([nums[i], nums[j], nums[k]]) return rnums; 嗯，不愧是我，直接超时 好的，我们再想想其他办法= = 发现一个问题，如果前面的数相加已经超过0，那么第三个数就不用继续判断，就可以省下一部分速度，这也是一种剪枝了 12345678910111213141516171819202122232425262728class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums = sorted(nums) rnums = [] for i in range(len(nums)): if nums[i] &gt; 0: break for j in range(i+1, len(nums)): if nums[i] + nums[j] &gt; 0: break for k in range(j+1, len(nums)): if nums[i] + nums[j] + nums[k] &gt; 0: break if nums[i] + nums[j] + nums[k] == 0: flag = 1 for a in rnums: if a == [nums[i], nums[j], nums[k]]: flag = 0 break if flag: rnums.append([nums[i], nums[j], nums[k]]) return rnums; 发现确实速度上是快一些，从290个测试用例走到了311个测试用例，那么还有什么优化方法呢，发现我之前的查重方法是遍历已找到的三数组，那么现在我试着从循环时判断 1234567891011121314151617181920212223242526class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums.sort() rnums = [] for i in range(len(nums)): if i == 0 or nums[i] &gt; nums[i-1]: if nums[i] &gt; 0: break for j in range(i+1, len(nums)): if j == i+1 or nums[j] &gt; nums[j-1]: if nums[i] + nums[j] &gt; 0: break for k in range(j+1, len(nums)): if k == j+1 or nums[k] &gt; nums[k-1]: if nums[i] + nums[j] + nums[k] &lt; 0: continue elif nums[i] + nums[j] + nums[k] == 0: rnums.append([nums[i], nums[j], nums[k]]) break return rnums; 好的 ，明显快一些，但是311用例明显是我的一生之敌（要不然把311用例算出来然后if掉算了= =||玩笑），既然是两层遍历那就把后两层遍历用左右的双指针法减少遍历次数吧，发现双指针法。。。真TM好用，连去重都自动做好了 1234567891011121314151617181920212223242526272829class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums.sort() rnums = [] for i in range(len(nums)): if i == 0 or nums[i] &gt; nums[i-1]: l = i + 1 r = len(nums) - 1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s == 0: rnums.append([nums[i], nums[l], nums[r]]) l += 1 r -= 1 while l &lt; r and nums[l] == nums[l-1]: l += 1 while r &gt; l and nums[r] == nums[r+1]: r -= 1 elif s &gt; 0: r -= 1 else: l += 1 return rnums; 双指针大法好！ 无论遇到什么困难，都不要害怕，奥利给！🍺","path":"2019/12/02/leetcode - 三数之和2/","date":"12-02","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 三数之和","text":"leetcode: 三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] n个整数找到所有的a + b + c = 0，二话不说，我们先遍历试试 123456789101112131415161718192021class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums = sorted(nums) rnums = [] for i in range(len(nums)): for j in range(i+1, len(nums)): for k in range(j+1, len(nums)): if nums[i] + nums[j] + nums[k] == 0: flag = 1 for a in rnums: if a == [nums[i], nums[j], nums[k]]: flag = 0 break if flag: rnums.append([nums[i], nums[j], nums[k]]) return rnums; 嗯，不愧是我，直接超时 好的，我们再想想其他办法= =","path":"2019/12/01/leetcode - 三数之和/","date":"12-01","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 最后一个单词的长度","text":"leetcode: 最后一个单词的长度给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 12输入: &quot;Hello World&quot;输出: 5 我们要找到最后一个单词的长度那就找到最后一个单词就好了，也就是说用正则表达式把空格隔开找到最后一段就完成了。 1234567891011class Solution(object): def lengthOfLastWord(self, s): \"\"\" :type s: str :rtype: int \"\"\" s1 = s.split(); if len(s1) == 0: return 0 else: return len(s1[len(s1) - 1]) 咸鱼很难受，咸鱼又咸鱼了。 今天就这样了，再肝一手双生视界。: - )","path":"2019/11/30/leetcode - 最后一个单词的长度/","date":"11-30","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 最大子序和","text":"leetcode: 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 首先，我们的第一个想法是所有可能是有穷的，暴力破解是ok的，但是想想就很麻烦，毕竟所有结果遍历一遍是指数递增的。所以我们就需要找到一些他的规律 定义一个函数f(n)，以第n个数为结束点的子数列的最大和，存在一个递推关系f(n) = max(f(n-1) + A[n], A[n]); 将这些最大和保存下来后，取最大的那个就是，最大子数组和。因为最大连续子数组 等价于 最大的以n个数为结束 有了这样的规律（不能说都是网上找来的= =），就不难得到推导代码了 123456789class Solution(object): def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" for i in range(1, len(nums)): nums[i]= nums[i] + max(nums[i-1], 0) return max(nums) 这一题说简单也简单，只要根据规律写代码就好了，但是说难也难，因为没有规律就要么暴力或者滑窗的方法就要麻烦许多，不得不感叹一下，数学大法好啊 咸鱼一直在鸽，外面风好大，咸鱼好害怕。","path":"2019/11/28/leetcode-最大子序列/","date":"11-28","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 括号生成","text":"leetcode: 括号生成给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 这一题是从一道简单题推过来的，那道题是这样，判断一个括号串是否有效，当时用的是栈的知识，那么这一题的区别就在找到括号生成的规律，现在我们可以分析一下它的规律了 首先长度肯定是两倍给出的n 左括号与右括号相等 在任何位置左括号数都要大于等于右括号 好的，那么为了列出这所有的可能，我们需要用到回溯法 1234567891011121314class Solution(object): def generateParenthesis(self, N): ans = [] def backtrack(S = '', left = 0, right = 0): if len(S) == 2 * N: ans.append(S) return if left &lt; N: backtrack(S+'(', left+1, right) if right &lt; left: backtrack(S+')', left, right+1) backtrack() return ans 回溯法是指比如走迷宫有很多路，我们需要一个一个路的探，通了就是一个结果，为了实现这个算法思想，我们一般用递归的思路来完成他。 好的，又是一条咸鱼，不过本欧皇昨天抽奖抽到一个异色初音，可以来一期开箱博客= =。","path":"2019/11/22/leetcode - 括号生成/","date":"11-22","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 报数","text":"leetcode: 报数报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 123451. 12. 113. 214. 12115. 111221 1 被读作 “one 1” (“一个一”) , 即 11。11 被读作 “two 1s” (“两个一”）, 即 21。21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 这一题看起来有点迷。主要是做一个循环不断让下一个表示上一段的数字 好的，既然是简单的循环，我们就来看看代码 12345678910111213141516171819202122class Solution(object): def countAndSay(self, n): \"\"\" :type n: int :rtype: str \"\"\" s = \"1\" for i in range(2, n+1): count = 0 a = s[0] temp = \"\" for j in s: if a == j: count += 1 else: temp += str(count) + a count = 1 a = j temp += str(count) + a s = temp return s 中规中矩，循环通过，时间复杂度为一个n^2 ? 这个复杂度可能不止，但是有一个我万万没想到的方法就是看到了n的范围，那么把从1 到 30都列一遍时间复杂度就是 1 ！！！？？？ 虽然没必要但是确实很屌= = 今天也是一条咸鱼呢，快乐咸鱼每一天！","path":"2019/11/21/leetcode - 报数/","date":"11-21","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 搜索插入位置","text":"leetcode: 搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 好的，简单题终结者石锤了= =|| 这题就是一遍遍历过去就完事了 1234567891011121314class Solution(object): def searchInsert(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" for i in range(len(nums)): if nums[i] == target: return i elif nums[i] &gt; target: return i return len(nums) 我不想咸鱼啊，可是大脑他不允许啊艹！明天又大一岁了，还是努点力吧 : - ( 【在，为什么咸鱼！】 【因为懒啊！】","path":"2019/11/16/leetcode - 搜索插入位置/","date":"11-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 盛最多水的容器","text":"leetcode: 盛最多水的容器给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 示例: 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 这一题我在草稿纸上比比划划好久才搞清楚逻辑，首先，乍一看n个非负整数里面找到最大面积需要暴力遍历一遍，但是遍历是最没办法的办法–它极有可能超时，所以我们需要找到它的规律 对于面积的计算应该是底的长度和最短的高的乘积 然后如何找到这两条边就是我们的关键了，我们需要两个边，所以我们最好从左右两边最远的位置开始找，不断找到更大值才是题目关键，从短的一边开始找，因为高的一边无论怎么找计算的边都是短边，那么面积只会更小，所以我们不断从找更高的边并更新最大面积值，这就是这一题的灵魂所在了 捋清楚了我们就上代码 1234567891011121314151617181920class Solution(object): def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" cleft = 0 cright = len(height) - 1 s = min(height[cleft], height[cright]) * (cright - cleft) ss = 0 while cright &gt; cleft: if height[cleft] &gt; height[cright]: cright -= 1 else: cleft += 1 ss = min(height[cleft], height[cright]) * (cright - cleft) if s &lt; ss: s = ss return s 也许会有人疑惑是否在这样的遍历中会错过最大值，我们可以分析一下,我们还是看看大佬的比我分析得好多了 https://leetcode-cn.com/problems/container-with-most-water/solution/shuang-zhi-zhen-fa-zheng-que-xing-zheng-ming-by-r3/ 另外，实际上在左右两边相等时应该还要有一点考量，但是既然过了那就算了= = 今天开始锻炼身体，可能，这就是淬体吧= =","path":"2019/11/12/leetcode-盛最多水的容器/","date":"11-12","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 字符串转换整数 (atoi)","text":"leetcode: 字符串转换整数 (atoi)请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 这一题是需要实现一个函数，函数内容就是把字符串转为整数，在c/c++中有一个atoi的函数就是这个功能（to int），那么我们来分析一下这一题的方法 首先，需要丢弃无用开头空格，我们可以用之前提到过的strip来去头去尾的空格 然后第一个字符可能是正负号，后面是连续的数字，这一部分就需要用到正则表达式了 感谢这一题，让我回想起了被正则表达式支配的恐惧 12345678910class Solution(object): def myAtoi(self, str): \"\"\" :type str: str :rtype: int \"\"\" str1 = \"\" str1 = str.strip(\" \") str1 = int(*re.findall('^[\\+\\-]?\\d+', str1)) return min(max(str1, -2**31), 2**31-1) 这段正则表达式是和评论多次印证和比较得出来的（对不起，我太菜了= =），功能就是^从字符串开头[\\+\\-]?可能有一个加号或者减号，\\d+后面有多个数字 大致上这里就完成了，后面的就是判断一下范围 ok，这周事情多，身体还被体测搞废了，尽量不断吧。","path":"2019/11/11/leetcode - 字符串转换整数/","date":"11-11","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 实现 strStr()","text":"leetcode: 实现 strStr()实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 这一题的道理就遍历就好，只是需要考虑一下为空的情况 代码如下 1234567891011121314151617class Solution(object): def strStr(self, haystack, needle): \"\"\" :type haystack: str :type needle: str :rtype: int \"\"\" if needle == \"\": return 0 for i in range(len(haystack) - len(needle) + 1): for j in range(len(needle)): if haystack[i+j] != needle[j]: break if j == len(needle) - 1: return i return -1 今天也很短= =，没得办法，还有作业的嘛","path":"2019/11/08/leetcode-实现 strStr()/","date":"11-08","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 移除元素","text":"leetcode: 移除元素给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 这一题关键点就是只能用一个额外空间，那么就是说必须在原数组中修改，那么事情就变得简单了，我们可以用两个标记，标记一遍历，标记二写入，等遍历完了，那么也就移除完了。 代码如下 12345678910111213141516class Solution(object): def removeElement(self, nums, val): \"\"\" :type nums: List[int] :type val: int :rtype: int \"\"\" left = 0 right = 0 for i in nums: if i != val: nums[left] = nums[right] left += 1 right += 1 return left 啊~ 又是一道简单题，莫得办法，今天云顶之弈s2更新了，太快乐了，9光强无敌= =","path":"2019/11/07/leetcode - 移除元素/","date":"11-07","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 无重复字符的最长子串","text":"leetcode: 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 这个问题首先我们可以想到的就是暴力破解，（依稀记得以前一个数学老师的三大鬼才解法，暴力破解，数学归纳，容易证得= =），但是暴力破解就就要把所有情况考虑进去，我们可以算一下时间复杂度 设一长度为n的字符串，当考虑答案为n的情况就需要n^2的时间，然后一共有1 + 2 + 3 + 4…..n-1种情况，那么最坏要达到n^3以上的复杂度，所以我们最好不要用暴力破解 我们就采用了一种滑动窗口方法，故名思义，滑动窗口就是一个左右边界不确定变长的串，代码如下 123456789101112131415161718192021class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" l = [] //滑动窗口 count = 0 //最长串长度 Ncount = 0 //现在串的长度 left = 0 //窗口左边位置 right = 0 //窗口右边位置 for i in range(len(s)): //遍历字符串 Ncount+= 1 //每加一个字符，长度加一 while s[i] in l: //检查是否有重复 l.remove(s[left]) //左窗口不断右滑直到没有重复字符 left += 1 Ncount -= 1 if Ncount &gt; count: count = Ncount l.append(s[i]) return count 实际上，滑动窗口在计算机网络信息传递时有很重要的作用，这一题可以辅助学习 嘛~ 今天的leetcode就这样了，晚点要是做完了做一期B样条曲线 啊，不想上晚课啊艹","path":"2019/11/06/leetcode-无重复字符的最长字段/","date":"11-06","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 删除排序数组中的重复项","text":"leetcode: 删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 这个的思路很清楚，就简单的遍历一遍，把前几个数字的内容替换就好 123456789101112131415class Solution(object): def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) == 0: return 0 count = 0 for i in nums: if nums[count] != i: count += 1 nums[count] = i return count+1 这题比较简单，就到这里吧。 唉，我是真的懒。。。明天继续","path":"2019/11/05/leetcode-删除排序数组中的重复项/","date":"11-05","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"数据库实验二","text":"数据库实验二实验一已经完成了，虽然有点小插曲 我什么场面没见过 这场面我真没见过 事不宜迟，开始实验二 实验二要求:1．设计与建立上课考勤表****Attend_???，能登记每个学生的考勤记录包括正常、迟到、旷课、请假。能统计以专业为单位的出勤类别并进行打分评价排序，如迟到、旷课、请假分别扣2，5，1分。可以考虑给一初始的分值，以免负值。 2．为major表与stud表增加sum_evaluation 数值字段，以记录根据考勤表Attend_???(Attendance)中出勤类别打分汇总的值。 3．建立个人考勤汇总表stud_attend与专业考勤表major_attend，表示每个学生或每个专业在某时间周期（起始日期，终止日期）正常、迟到、旷课、请假次数及考勤分值。 4．根据major表中的值与stud中的值，为考勤表Attend输入足够的样本值，要求每个专业都要有学生，有部分学生至少要有一周的每天5个单元（12，34，56，78，90，没有课的单元可以没有考勤记录）的考勤完整记录，其中正常、迟到、旷课、请假 可以用数字或字母符号表示。 5．建立触发器，当对考勤表Attend表进行相应插入、删除、修改时，对stud表的sum_evaluation 数值进行相应的数据更新。 6．建立过程，生成某专业某时段（起、止日期）的考勤汇总表major_attend中各字段值，并汇总相应专业，将考勤分值的汇总结果写入到major表中的sum_evaluation中。 首先，这次的实验和上次不一样，几个条件之间是有关系的，为了捋清楚，我先从二这种比较明确的做起 增加打分汇总值代码如下 1234alter table major_J314 drop column sum_evaluation; //删除字段，备用alter table stud_J314 drop column sum_evaluation; //删除字段，备用alter table major_J314 add sum_evaluation int Default 100 Not NULL;alter table stud_J314 add sum_evaluation int Default 100 NOT NULL; 这个地方注意了，oracle必须NOT NULL 在 Default后面，不然报错= = 建立考勤表然后我们来捋一捋考勤表的字段与约束 统计学生，需要学生号SNO字段 考勤记录，需要记录ATTEND字段 需要统计以专业为单位，需要MajorNo字段 考勤需要记录时间，需要SDATE字段 四中把考勤一天分为5个单元，需要UNIT字段 建表如下： 123456789101112131415drop table attend_J314;create table attend_J314( SNO varchar(20), ATTEND int, MajorNo char(20), SDATE date, UNIT varchar(10), constraint aj_pk primary key(SNO, SDATE, UNIT)， constraint aj_unit check (UNIT in ('12','34','56','78','90')), constraint aj_attend check (ATTEND in ('0','1','2','5'))); 初步建表就这样了 对了，发现一个问题，千万不要在最后一个字段后面加逗号，他会把 ) 也当作字段读入，这个和css或者一些编程语言不一样了= = 建立个人考勤表和专业考勤表个人/专业考勤表 个人的表需要SNO学号/专业号MajorNo 需要开始日期SDate 需要结束日期EDate 需要正常次数NCount 需要迟到次数LCount 需要旷课次数ABCount 需要成绩score 开始建表 123456789101112131415161718192021222324252627282930313233drop table stud_attend_J314;drop table major_attend_J314;create table stud_attend_J314( SNO varchar(10), SDate date, EDate date, NCount int, LeCount int, LaCount int, ABCount int, constraint saj_pk primary key(SNO, SDate, EDate), constraint saj_sno_fk foreign key(SNO) references stud_J314(SNO));create table major_attend_J314( MajorNo varchar(10), SDate date, EDate date, NCount int, LeCount int, LaCount int, ABCount int, score int, constraint maj_pk primary key(MajorNo, SDate, EDate), constraint maj_sno_fk foreign key(MajorNo) references major_J314(MajorNo)); 同理，初步建表就这样了 插入数据又到了喜闻乐见的插（编）入（造）数（脑）据（洞）时间了，特别要求部分学生有一周一天五个单元的记录 代码如下 1234567891011121314151617181920212223242526insert into attend_J314 values('0902170314', '0', '02', to_date('20191028', 'YYYYMMDD'), '56');insert into attend_J314 values('0902170314', '1', '02', to_date('20191028', 'YYYYMMDD'), '78');insert into attend_J314 values('0902170314', '2', '02', to_date('20191029', 'YYYYMMDD'), '12');insert into attend_J314 values('0902170314', '0', '02', to_date('20191029', 'YYYYMMDD'), '78');insert into attend_J314 values('0902170314', '1', '02', to_date('20191030', 'YYYYMMDD'), '90');insert into attend_J314 values('0902170314', '0', '02', to_date('20191031', 'YYYYMMDD'), '56');insert into attend_J314 values('0902170314', '0', '02', to_date('20191101', 'YYYYMMDD'), '34');insert into attend_J314 values('0902170314', '0', '02', to_date('20191101', 'YYYYMMDD'), '90');insert into attend_J314 values('0903170101', '5', '02', to_date('20191028', 'YYYYMMDD'), '56');insert into attend_J314 values('0903170102', '0', '02', to_date('20191028', 'YYYYMMDD'), '78');insert into attend_J314 values('0903170102', '2', '02', to_date('20191029', 'YYYYMMDD'), '12');insert into attend_J314 values('0903170103', '0', '02', to_date('20191029', 'YYYYMMDD'), '78');insert into attend_J314 values('0903170105', '1', '02', to_date('20191030', 'YYYYMMDD'), '90');insert into attend_J314 values('0903170108', '2', '02', to_date('20191031', 'YYYYMMDD'), '56');insert into attend_J314 values('0903170109', '0', '02', to_date('20191101', 'YYYYMMDD'), '34');insert into attend_J314 values('0903170109', '5', '02', to_date('20191101', 'YYYYMMDD'), '90');insert into attend_J314 values('0904170101', '0', '02', to_date('20191028', 'YYYYMMDD'), '56');insert into attend_J314 values('0904170102', '1', '02', to_date('20191028', 'YYYYMMDD'), '78');insert into attend_J314 values('0904170102', '0', '02', to_date('20191029', 'YYYYMMDD'), '12');insert into attend_J314 values('0904170103', '0', '02', to_date('20191029', 'YYYYMMDD'), '78');insert into attend_J314 values('0904170105', '1', '02', to_date('20191030', 'YYYYMMDD'), '90');insert into attend_J314 values('0904170108', '0', '02', to_date('20191031', 'YYYYMMDD'), '56');insert into attend_J314 values('0904170109', '0', '02', to_date('20191101', 'YYYYMMDD'), '34');insert into attend_J314 values('0904170109', '0', '02', to_date('20191101', 'YYYYMMDD'), '90'); 在我准备插入的时候我发现一个问题，题设要求与实际需要都要是在stud和major表有的前提下的，所以我需要在attend表加上上面两个表的外键才对，添加如下重新建表 12345678910111213141516171819drop table attend_J314;create table attend_J314( SNO varchar(20), ATTEND int, MajorNo varchar(20), SDATE date, UNIT varchar(10), constraint aj_pk primary key(SNO, SDATE, UNIT)， constraint aj_unit check (UNIT in ('12','34','56','78','90')), constraint aj_attend check (ATTEND in ('0','1','2','5')), constraint aj_sno_fk foreign key(SNO) references stud_J314(SNO), constraint aj_MajorNo_fk foreign key(MajorNo) references major_J314(MajorNo)); 以此类推，stud_attend与major_attend两个表都需要加上SNO的外键约束 1234constraint saj_sno_fk foreign key(SNO) references stud_J314(SNO)constraint maj_sno_fk foreign key(MajorNo) references major_J314(MajorNo) 做到这一步，表，数据和关系都基本建立完成了，下一步就是触发器和过程了 先是触发器，要求在对attend表修改时，对stud_attend进行相应修改，那么问题来了，我们的stud_attend表还没有插入数据，那就先做数据插入吧= = 1select 'insert into stud_attend_J314 values (\"'||SNO||'\", to_date(\"20190901\", \"YYYYMMDD\"), to_date(\"20200101\", \"YYYYMMDD\"), 0, 0, 0, 100);' from stud_J314; 在我把数据插入完后发现上一步的insert又走早了，需要先做触发器再做插入才比较好 attend表触发器我的打算是，先修改stud_attend_J314表再通过stud_attend_J314表的触发器触发stud_J314的修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354create or replace trigger T_attend_J314 after insert or delete or update on attend_J314 for each rowbegin if inserting then update stud_J314 set sum_evaluation = sum_evaluation - :new.ATTEND where SNO = :new.SNO; /* if :new.ATTEND = 1 then update stud_attend_J314 set LeCount = LeCount + 1 where SNO = :new.SNO; elsif :new.ATTEND = 2 then update stud_attend_J314 set LaCount = LaCount + 1 where SNO = :new.SNO; elsif :new.ATTEND = 5 then update stud_attend_J314 set ABCount = ABCount + 1 where SNO = :new.SNO; elsif :new.ATTEND = 0 then update stud_attend_J314 set NCount = NCount + 1 where SNO = :new.SNO; end if; */ elsif deleting then update stud_J314 set sum_evaluation = sum_evaluation + :old.ATTEND where SNO = :old.SNO; /* if :old.ATTEND = 1 then update stud_attend_J314 set LeCount = LeCount - 1 where SNO = :old.SNO; elsif :old.ATTEND = 2 then update stud_attend_J314 set LaCount = LaCount - 1 where SNO = :old.SNO; elsif :old.ATTEND = 5 then update stud_attend_J314 set ABCount = ABCount - 1 where SNO = :old.SNO; elsif :old.ATTEND = 0 then update stud_attend_J314 set NCount = NCount - 1 where SNO = :old.SNO; end if; */ elsif updating then update stud_J314 set sum_evaluation = sum_evaluation - :new.ATTEND where SNO = :new.SNO; update stud_J314 set sum_evaluation = sum_evaluation + :old.ATTEND where SNO = :old.SNO; /* if :old.ATTEND = 1 then update stud_attend_J314 set LeCount = LeCount - 1 where SNO = :old.SNO; elsif :old.ATTEND = 2 then update stud_attend_J314 set LaCount = LaCount - 1 where SNO = :old.SNO; elsif :old.ATTEND = 5 then update stud_attend_J314 set ABCount = ABCount - 1 where SNO = :old.SNO; elsif :old.ATTEND = 0 then update stud_attend_J314 set NCount = NCount - 1 where SNO = :old.SNO; end if; if :new.ATTEND = 1 then update stud_attend_J314 set LeCount = LeCount + 1 where SNO = :new.SNO; elsif :new.ATTEND = 2 then update stud_attend_J314 set LaCount = LaCount + 1 where SNO = :new.SNO; elsif :new.ATTEND = 5 then update stud_attend_J314 set ABCount = ABCount + 1 where SNO = :new.SNO; elsif :new.ATTEND = 0 then update stud_attend_J314 set NCount = NCount + 1 where SNO = :new.SNO; end if; */ end if;end; 插入就不测试了，上面的都是例子，我们测试一下修改与删除 123delete from attend_J314 where SNO = '0904170105';insert into attend_J314 values('0904170105', '1', '02', to_date('20191030', 'YYYYMMDD'), '90');update attend_J314 set ATTEND = 5 where SNO = '0904170105'; 左调右调应该没什么问题了= = 下一步是建立一个过程，过程就是一个搜索并更新的过程 12345678910111213141516171819202122232425262728create or replace procedure p_attend_J314( Num in char, s_date in date, e_date in date)isa int := 0;scount int := 0;normal int := 0;leave int := 0;late int := 0;absent int := 0;begin for attend in (select ATTEND from attend_J314 where MajorNo = Num and SDATE &gt;= s_date and SDATE &lt;= e_date)loop scount := scount + 1; if attend.ATTEND = 0 then normal := normal + 1; elsif attend.ATTEND = 1 then leave := leave + 1; elsif attend.ATTEND = 2 then late := late + 1; elsif attend.ATTEND = 5 then absent := absent + 1; end if; end loop; scount := (scount * 100 - leave - late * 2 - absent * 5) / scount; insert into major_attend_J314 values(Num, s_date, e_date, normal, leave, late, absent, scount);end p_attend_J314; 下面就是对过程的测试了 1exec p_attend_J314(&apos;02&apos;,&apos;20-10月-2019&apos;,&apos;03-11月-2019&apos;);","path":"2019/11/02/数据库实验二/","date":"11-02","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://nomalbuthappy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"leetcode - 有效的括号","text":"leetcode: 有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 这题如果让我用C/C++就是用栈的知识了，对于括号不断压栈直到有相对应的消掉，现在用python也是一样的 12345678910111213141516class Solution(object): def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" dict = &#123;\"(\" : 1, \")\" : -1, \"&#123;\" : 2, \"&#125;\" : -2, \"[\" : 3, \"]\" : -3&#125; str_s = [] for i in s: if len(str_s) == 0: str_s.append(i) elif dict[i] + dict[str_s[-1]] == 0: del str_s[-1] else: str_s.append(i) return len(str_s) == 0; 评论区看到一些有趣的做法，对啊，python可以直接替换，替换到最后若为空就是真的 1234567class Solution: def isValid(self, s): while '&#123;&#125;' in s or '()' in s or '[]' in s: s = s.replace('&#123;&#125;', '') s = s.replace('[]', '') s = s.replace('()', '') return s == '' 简洁明了不过因为循环的问题需要遍历多次比如[[[]]]这样的就需要循环很多次浪费了时间 还有一个C的大佬，原本C就速度快，这个大佬这个几乎0ms= = 12345678910111213141516171819202122int length=0;//定义字符串长度while(*(s+length))length++;//获取字符串长度char* ptr=(char*)malloc(length/2);//分配内存空间memset(ptr,0,length/2);//初始化内存空间int i,a=0;for(i=0;i&lt;length;i++)&#123; if((*(s+i)=='(')||(*(s+i)=='&#123;')||(*(s+i)=='[')) &#123; a++; *(ptr+a)=*(s+i); &#125; //'('与')'的ASCII值差1，'['与']'，'&#123;'与'&#125;'的ASCII值差2 else if((*(s+i)==(*(ptr+a)+1))||(*(s+i)==(*(ptr+a)+2))) &#123; a--; &#125; else return 0;&#125;if(a) return 0;return 1; 简单来说，这题用栈还是快一些的 啊啊啊，今天还是简单题，不行，明天做道困难题= =，还是不太行，明天有课，做道中等题，后天做困难 关于自己的生活，我和你都不是读者，而是作者。至少结局，还是能自己说了算的。 -「银魂」","path":"2019/10/31/leetcode-有效的括号/","date":"10-31","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 合并两个有序链表","text":"leetcode: 合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 还是一道简单题，是对于两个已经有序了的链表的合并操作，思路就是不断取两个链表的链头进行比较，取小的值作为新链表的尾结点值，两个链表遍历到都为空时两个链表就合并为新链表了 12345678910111213141516171819202122232425262728293031323334class Solution(object): def mergeTwoLists(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" lhead = ListNode(0) lpre = lhead while l1 and l2: if l1.val &lt;= l2.val: a = ListNode(l1.val); lpre.next = a; l1 = l1.next; lpre = lpre.next; else: a = ListNode(l2.val); lpre.next = a; l2 = l2.next; lpre = lpre.next; while l1 != None: a = ListNode(l1.val); lpre.next = a; l1 = l1.next; lpre = lpre.next; while l2 != None: a = ListNode(l2.val); lpre.next = a; l2 = l2.next; lpre = lpre.next; return lhead.next; 可以发现在时间和内存上都是有问题，能通过测试但是可以做一些优化，直接用提供的链表结点，这样就省下了建立结点的空间与时间 123456789101112131415161718192021class Solution(object): def mergeTwoLists(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" lhead = ListNode(0) lpre = lhead while l1 and l2: if l1.val &lt;= l2.val: lpre.next = l1; l1 = l1.next; else: lpre.next = l2; l2 = l2.next; lpre = lpre.next; if l1 != None: lpre.next = l1; else: lpre.next = l2; 除了上面的解法，官方的解法还有一个直接调用函数的（python不仅包多，稀奇古怪的函数也多啊= =） 123456789101112class Solution: def mergeTwoLists(self, l1, l2): if l1 is None: return l2 elif l2 is None: return l1 elif l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2 今天看漫画的鬼才汉化组 打啵教程： 仪容仪表很重要 前提你得有女票 by全员已婚的飞橙汉化组 我酸了: - (","path":"2019/10/31/leetcode-合并两个有序链表/","date":"10-31","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 两数相加","text":"leetcode: 两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-two-numbers 这题是一道中等难度的题（可怜我这个彩笔前几天只敢做简单题），这题设计的一个关键就是链表 首先，链表中的两数相加应该是和加法一样各个位相加，而各个位相加的话就会有一个进位的问题，这题的关键就是处理这个进位的问题 代码如下： 12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" re = ListNode(0) //初始化一个链表节点，作为头节点 r = re //作为建立链表的节点 carry = 0 while(l1 or l2): x = l1.val if l1 else 0 y = l2.val if l2 else 0 s = carry + x + y carry = s // 10 r.next = ListNode(s % 10) r = r.next if (l1 != None): l1 = l1.next if (l2 != None): l2 = l2.next if (carry &gt; 0): r.next = ListNode(1) return re.next 其中有一个语法 1x = l1.val if l1 else 0 意思同 1234if l1: x = l1.valelse: x = 0 实际上这个还有一个优化的空间，就是在发现了l1 或 l2为空的时候让 r 指向非空的链，节约算法空间与时间 上面的方法确实可行，在一条链结束的时候若有进位，而后面又全都是9，那就需要一个循环，这样可以提高一定的效率，下次二刷的时候再实现吧 LPL联手出现保送决赛= =，但是skt是最强的: - )","path":"2019/10/27/leetcode-两数相加/","date":"10-27","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"自搭hexo博客","text":"自搭hexo博客教程hexo是一个可以轻量方便依托于githubpage的博客，原本我是自搭博客，从前端到后台全包干，但是这样不仅自己设计上面存在问题需要不断，修改越改心越累，也没办法把全部精力留在博客质量上，所以我还是选择了hexo，还省了一个服务器，美滋滋= = 注 以下教程的操作系统是window，linux请寻找其他相应教程或等待后续教程 准备工作 注册一个github账号 操作系统安装node.js。这个可以搜索官网免费下载安装后用 12node -vnpm -v 检查是否安装成功 安装git，同样是搜索官网下载安装好后，用 1git --version 检查一下环境 下载3.x以后版本的hexo 先创建一个文件夹用于保存hexo，然后右键gitbash，输入 12345npm install hexo-cli -g //等待进度条读完后就下载完成了hexo init myblog //初始化一个myblog，也可以是其他名字cd myblog //进入myblog文件夹hexo g //生成博客hexo server //生成预览 默认localhost:4000可以浏览 创建仓库新建一个仓库，在右上角的加号new repository，创建一个和用户名相同的仓库，后加.github.io 只有这样在部署githubpage的时候才会被识别，所以从这个角度来说一个用户只能有一个github提供的域名 生成SSH并添加到github回到git bash中 12345git config --global user.name &quot;yourname&quot; //存入你的github用户名git config --global user.email &quot;youremail&quot; //存入你注册时用的邮箱git config user.name //检查一遍你的输入git config user.email //同上ssh-keygen -t rsa -C &quot;youremail&quot; //生成SSH，在电脑里找到它，返回有提示位置 其中，我们要用的是公钥公开给github，就是哪个id_rsa.pub，复制里面的内容，在右上角用户找到setting，点击找到SSH keys新建一个把id_rsa.pub复制进去，再回到gitbash 1ssh -T git@github.com //返回success就是部署成功 配置博客打开myblog中的_config.yml配置文件，找到deploy，修改为 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 再回到gitbash 1234npm install hexo-deployer-git --save //安装deploy-git用于推送到github上hexo clean //用于清理之前生成的文件hexo g //generate的缩写，生成博客hexo d //deploy的缩写，部署到github 过一会儿，你就可以在http://yourname.github.io上看到你的博客了，他现在还很简单，没有内容没有主题 内容在source/_post中添加 主题可以直接找，每个主题的要求不同配置方法也不同所以基本上都有配置文档或教程 以上 ps 有点没写好，很多瑕疵 ma，算了，反正没有人看= = 有点冷啊，咸鱼落泪 : - )","path":"2019/10/25/自搭hexo博客/","date":"10-25","excerpt":"","tags":[]},{"title":"leetcode - 最长公共前缀","text":"leetcode: 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot; 首先，这一题的思路是从头到尾两辆比较，上一次比较的公共前缀用于下一次比较，代码如下： 123456789101112131415161718192021222324class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" if strs == []: return \"\" else: s = strs[0] for i in range(1, len(strs)): temp = \"\" if strs[i] == \"\": return \"\" else: for j in range(min(len(strs[i]), len(s))): if(strs[i][j] == s[j]): temp += s[j] if j == min(len(strs[i]), len(s)) - 1: s = temp else: s = temp; break; return s 可以看到，这个方法我们用了很多的特殊情况处理，比如只有空list，list中有空串等（一次次出错中补出来的= =） 评论中有一些启发的思路，比如说，字符串是可以比较大小的，那么不就可以直接只比较最大和最小的两项吗 代码如下 123456789101112131415161718class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" temp = \"\" if strs == []: //也能写成if not strs return \"\" else: smax = max(strs) smin = min(strs) for i in range(min(len(smax), len(smin))): if smax[i] == smin[i]: temp += smax[i] else: break return temp 另外就是利用zip函数，把str对齐压缩然后去重，取最短的对象的函数特性正好可以利用到，在list中找到长度大于1前的就是公共前缀，有点神奇： 1234567891011class Solution(object): def longestCommonPrefix(self, strs): if not strs: return \"\" ss = list(map(set, zip(*strs))) res = \"\" for i, x in enumerate(ss): x = list(x) if len(x) &gt; 1: break res = res + x[0] return res 这是今天的份了。 今天雨有点大，鞋也湿了，头有点痛晚上还有实验。。。 心塞的看看桌上的老婆，发现双十一买不起新老婆 呵，男人","path":"2019/10/25/leetcode-最长公共前缀/","date":"10-25","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 罗马数字转整数","text":"leetcode: 罗马数字转整数例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 罗马数字转整数乍一看觉得需要多方面的考虑比如每个字符之间的组合分别考虑之类的，但是再细看我们可以发现，实际上我们做计算时它遵循的只有两个规律 左边大于右边时加上这个左边的数 左边小于右边时减去这个左边的数 那么我们就可以着手编程了: 12345678910class Solution(object): def romanToInt(self, s): d = &#123;'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000&#125; ans=0 for i in range(len(s)): if i&lt;len(s)-1 and a[s[i]]&lt;a[s[i+1]]: ans-=a[s[i]] else: ans+=a[s[i]] return ans 膜拜大佬，有个两行就解决的大佬，分析一下他的解法 123456class Solution: def romanToInt(self, s: str) -&gt; int: d = &#123;'I':1, 'IV':3, 'V':5, 'IX':8, 'X':10, 'XL':30, 'L':50, 'XC':80, 'C':100, 'CD':300, 'D':500, 'CM':800, 'M':1000&#125; return sum(d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s)) 链接：https://leetcode-cn.com/problems/roman-to-integer/solution/2-xing-python-on-by-knifezhu/ 首先用map把各个字符的数字列出来，不过大佬与众不同的是这里用了遍历的方法，就是上面我说的每个字母之间的组合分别考虑全部列出 比如，IV为4，先读I为1，再读V，IV为3，加起来就是4达到了IV是4的效果再从头到尾遍历一边就可以解决问题 今日份完工！ 话说不知道是脑抽还是什么买了一桶比我手臂还粗的饼干，真好，能吃一年了: - )","path":"2019/10/24/leetcode-罗马数字转整数/","date":"10-24","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"数据库实验 - oracle","text":"数据库实验选课的时候选了一门大型数据库，但是开学以来都没好好学习过 (当个人吧= =)，我本来以为以我原本的mysql与sqlserver的基础问题应该不大，但是oracle真是让我失策了，还有pl/sql令人头大，以下博客是自救过程中的学习与感悟 实验一 oracle安装首先是Oracle的安装，用任何搜索引擎搜索oracle然后打开download页面找到11c以后的版本下载 但是下载之前需要注册登陆一系列吧啦吧啦的操作，所以我这个小机灵鬼发现一个小办法= = 把下载按钮看一下开发者模式的链接，然后把链接复制下来用迅雷，bittorrent之类的下载器下载 12c版本的，以下为链接 https://download.oracle.com/otn/nt/oracle12c/121020/winx64_12102_database_1of2.zip https://download.oracle.com/otn/nt/oracle12c/121020/winx64_12102_database_2of2.zip 注意两个都要下载并解压到同一个文件夹，路径不带中文 双击setup.exe进行安装，后面按照自己的需要安装即可，有无法把握的细节可以自行搜索或者在留言栏留言 使用sqlplus打开命令行控制台cmd，输入 1sqlplus system/密码 在前面的安装过程中设置的密码，若未设置默认为manager 创建一个新用户： 1create user username identified by password; 给用户授权： 1grant resource, connect to username; 连接用户： 1connect username/password *2. *根据要求建立如下表 定义基本表格major????（专业）与stud_???(学生），关系模式如下(类型长度自定义)： major_???(MajorNo专业编号 Primary key, MNAME 专业名称,loc 地址 in(主校区，南校区，新校区，铁道校区，湘雅校区),mdean 专业负责人)） stud_???(SNO primary key, SNAME, SEX (男，女，其他),TEL ,E-MAIL (基本格式判断), birthday &gt;=’19990731’ ,MNO 班长学号 FK，MajorNo 专业编号 FK ) 其中学号的第3，4位为MajorNo（专业编号）。 创建专业表代码如下 12345678create table major_J314 ( MajorNo char(20) primary key, MNAME varchar(50), loc varchar(20), mdean varchar(20), constraint mj_loc check (loc IN ('主校区', '南校区', '新校区', '铁道校区', '湘雅校区'))); 测试check语句是否生效 12insert into major_J314 values('02', '计算机科学与技术', '123', '张祖平'); --违反条例insert into major_J314 values('02', '计算机科学与技术', '南校区', '张祖平'); --创建成功 注意，在插入过程中如果发现对表空间 ‘USERS’ 无权限，那么在system的权限下执行语句 1alter user username quota unlimited on users 创建学生表代码如下 12345678910111213141516171819202122create table stud_J314 ( SNO varchar(20) primary key, SNAME varchar(20), SEX varchar(5), TEL varchar(20), E_MAIL varchar(20), birthday date, MNO char(20), MajorNo char(20), constraint sj_sex check (sex IN ('男','女','其他')), constraint sj_E_MAIL check (REGEXP_LIKE (E_MAIL,'[a-zA-Z0-9._%-]+@[a-zA-Z0-9._%-]+\\.[a-zA-Z]&#123;2,4&#125;')), constraint sj_birthday check (to_char(birthday, 'yyyymmdd') &gt; '1999-07-31'), constraint sj_MNO foreign key (MNO) references stud_J314(SNO), constraint sj_MajorNo foreign key (MajorNo) references major_J314(MajorNo), constraint sj_sno check (substr(SNO, 3, 2) = MajorNo)); 测试成功用例 12insert into major_J314 values('02', '计算机科学与技术', '南校区', '张祖平');insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); 这个表的创建比上面的表明显困难，因为添加了更多的约束，我把约束与测试拿出来一个个分析 SEX性别必须是’男’,’女’,’其他’中的一个，这个我们在上一个表中已经实现 12insert into stud_J314 values ('0902170314', '颜灿', '1', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); --违反检查约束条件SJ_SEXinsert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); --已创建一行 E_MAIL需要约束成XXX@XXX.XXX的格式，为了更加精确，我用了oracle允许的正则表达式[a-zA-Z0-9.%-]+@[a-zA-Z0-9.%-]+.[a-zA-Z]{2,4}来对格式进行规范 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq', to_date('20001010', 'YYYYMMDD'), '0902170314', '02'); --违反检查约束条件SJ_E_MAIL MNO与MajorNo需要添加外键，MajorNo直接与之前的Major表关联成为外键，但是MNO我思来想去还是觉得他应该成为自己的表的主键的外键。 注意 当MajorNo与自己的主键关联时，也就是说插入班级的每个数据之前必须先插入班长的数据！！！否则就会出现外键找不到父项关键字的报错！！！ 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170313', '02'); --未找到父项关键字 然后就是生日的约束，这里需要用到 date 的数据类型，以及char与date之间的转化to_char(birthday, ‘yyyymmdd’)，to_date(birthday, ‘YYYYMMDD’)。 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('19981010', 'YYYYMMDD'), '0902170314', '02'); --违反检查约束条件SJ_BIRTHDAY 学号的第3，4位为MajorNo，所以我们需要截断字符串，需要用到方法substr(字符串, 第几个字符, 截取几个字符) 1insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '03'); --违反检查约束条件SJ_SNO 插入样本数据插入3个专业，如计算机科学与技术，物联网工程，数据科学与大数据技术，每个专业不少于10个人，其中包括自己的信息。 测试相关的完整性约束，并注意保留出错的提示，分析出错的原因。 根据上面分析的约束，我们需要先插入没有外键的表 major_U314 123insert into major_J314 values('02', '计算机科学与技术', '南校区', '张祖平');insert into major_J314 values('03', '物联网工程', '南校区', '张祖平');insert into major_J314 values('04', '数据科学与大数据技术', '南校区', '张祖平'); 下一个插入的就是学生表，但是注意了，学生表中由于约束到的是自己的主键，需要先插入班长的信息 1234567891011121314151617181920212223242526272829303132333435--班长学生insert into stud_J314 values ('0902170314', '颜灿', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0903170314', 'a', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '03');insert into stud_J314 values ('0904170314', 'b', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');--非班长学生insert into stud_J314 values ('0902170101', '1', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170102', '2', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170103', '3', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170104', '4', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170105', '5', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170106', '6', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170107', '7', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170108', '8', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0902170109', '9', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0902170314', '02');insert into stud_J314 values ('0903170101', '1', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170102', '2', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170103', '3', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170104', '4', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170105', '5', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170106', '6', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170107', '7', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170108', '8', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0903170109', '9', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0903170314', '03');insert into stud_J314 values ('0904170101', '1', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170102', '2', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170103', '3', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170104', '4', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170105', '5', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170106', '6', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170107', '7', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170108', '8', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');insert into stud_J314 values ('0904170109', '9', '男', '1', '123@qq.com', to_date('20001010', 'YYYYMMDD'), '0904170314', '04');--其他以此类推 实现权限控制为每个学生建立相关用户，实现权限控制，每个学生可查询自己的信息，班长可查询本班所有学生信息；为每个专业负责人建立用户，每个专业负责人可查询本专业所有学生信息。 首先我要先把用户建立好 1234567select MajorNo from major_J314;select MNAME from major_J314; //以上两行用来看= =select 'create user u'||MajorNo||' identified by p'||MajorNo||';' from major_J314;select 'drop user u'||MajorNo||';' from major_J314; //删除用户，这里是写了备用select SNO from stud_J314;select 'create user u'||SNO||' identified by p'||SNO||';' from stud_J314;select 'drop user u'||SNO||';' from stud_J314; //删除用户，这里是写了备用 划重点 这里的select ‘’语句只有选择出所有合适语句的作用而不会运行那么，我们就要先把语句选出来存起来再全部运行 先建立一个txt或sql文件，写入 1234567891011121314151617clear screenconn U_J314/YcYyj1234 连接用户名与密码spool offset heading offset echo offset feedback offspool d:\\blog\\user.txt选出后存储的地址文件，可以用txt---选择语句，注意，只有选择语句会留下记录---spool offset heading onset echo onset feedback onspool d:\\blog\\demo.txt运行过程的记录，同样用令一个文件记录@d:\\blog\\user.txt 运行user的内容spool off 但是，在我实际创建的过程中发现一个问题 — 权限不足= = 创建用户就需要系统管理员的权限了 1grant dba to U_J314(这里用自己的用户名); 下一步是每个人的权限 12select 'grant connect to u'||MajorNo||';' from major_J314;select 'grant connect to u'||SNO||';' from stud_J314; 建立一个视图并给予视图的权限 123456create view V_J314 as select * from stud_J314 where 'u'||SNO=user or 'u'||MNO=user or 'u'||majorNo=user;grant select on V_J314 to public;--测试数据select * from U_J314.V_J314 心态崩了，真就没办法过啊 补充之前和个沙雕一样，想一想不如每个人建立一个视图 代码如下 12345678select 'drop view V_'||SNO||';' from stud_J314;select 'create view V_'||SNO||' as select * from stud_J314 where SNO = '||SNO||' or MNO = '||SNO||';' from stud_J314;select 'grant select on V_'||SNO||' to u'||SNO||';' from stud_J314;select 'drop view V_'||MajorNo||';' from major_J314;select 'create view V_'||MajorNo||' as select * from stud_J314 where MajorNo='||MajorNo||';' from major_J314;select 'grant select on V_'||MajorNo||' to u'||MajorNo||';' from major_J314;测试数据select * from U_J314.V_(学号或年级号) 测试通过，任务完成: - )","path":"2019/10/23/数据库实验/","date":"10-23","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://nomalbuthappy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"leetcode - 整数反转","text":"leetcode: 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-integer 首先，反转整数需要考虑两点，一是是否有负号，有符号需要把符号放到最前面，二是末尾有没有0，有0需要去掉，因为数字首位是不能为零的。 考虑到python取模10时结果会是正数，所以把数字转为字符处理更为方便 另外，题设假设环境只能存储得下32位int整型数字，python不需要考虑数字长度，所以我们直接用if判断数字大小 代码如下： 12345678910111213class Solution: def reverse(self, x: int) -&gt; int: if x == 0: return 0 str_x = str(x) x = '' if str_x[0] == '-': x += '-' x += str_x[len(str_x)-1::-1].lstrip(\"0\").rstrip(\"-\") x = int(x) if -2**31&lt;x&lt;2**31-1: return x return 0 注意到其中用了[len(str_x)-1::-1]，意义是从len(str_x)开始，以-1递减的方式截取，达到反取的作用，第二位不写默认是0 lstrip方法，表示截取最左边的某个字符，多个重复全部截取 rstrip方法同上不过是截取右边 评论大佬中也有不处理为字符串的方法，就是对数字做取余处理，这里贴一下代码以供学习： 123456789101112131415161718192021222324class Solution: def reverse(self, x: int) -&gt; int: # 避免python负数取模的特性，改为对正数取整 num: int = x if x &gt; 0 else -x ans: int = 0 MAX_VALUE = 2147483647 MIN_VALUE = -2147483648 while(num != 0): pop: int = num % 10 if x &gt; 0: if (ans &gt; MAX_VALUE // 10) or (ans == MAX_VALUE // 10 and pop &gt; 7): # 正溢出 return 0 elif x &lt; 0: if (ans &gt; -MIN_VALUE // 10) or (ans == -MAX_VALUE // 10 and pop &gt; 8): # 负溢出 return 0 ans = ans * 10 + pop num //= 10 return ans if x &gt; 0 else -ans 想起樱木花道的经典台词：安西教练，你最光荣的时候是什么时候，是在日本国家队的时候吗？而我，只有现在了！ 菜鸟坚持一天至少一篇，先从简单起，慢慢来吧。","path":"2019/10/23/leetcode-整数反转/","date":"10-23","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 两数之和","text":"leetcode: 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 对这道题一开始的思路是两套循环遍历找到为目标值的两个数，代码如下: 123456class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if(nums[i] + nums[j] == target): return [i, j] 循环遍历一遍，时间复杂度是n^2，可以通过但是非常常规且有时会超时 经过评论大佬的启迪，做一次排序后首尾递进显然更快，复杂度为排序的nlogn 12345678910111213class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: sorted_id = sorted(range(len(nums)), key=lambda k: nums[k]) head = 0 tail = len(nums) - 1 sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]] while sum_result != target: if sum_result &gt; target: tail -= 1 elif sum_result &lt; target: head += 1 sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]] return [sorted_id[head], sorted_id[tail]] 这个速度明显会更快，但更花费空间 这样还不够，发现比较的都是数字，那么就有了更快的办法—hash字典 123456789class Solution: def twoSum(self, nums, target): hashmap = &#123;&#125; for index, num in enumerate(nums): another_num = target - num if another_num in hashmap: return [hashmap[another_num], index] hashmap[num] = index return None 用hash字典大大增加了内存但是速度快到了n 还是图样图森破 这是第一天份的，明天继续= =","path":"2019/10/23/leetcode两数之和/","date":"10-23","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"leetcode - 回文数","text":"leetcode: 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 这一题和整数反转很像，都需要给数做一个反转，但是从转为字符串的角度来看，反而更加简单了 代码如下： 12345678class Solution: def isPalindrome(self, x: int) -&gt; bool: str_x = str(x) x = '' if str_x[len(str_x) - 1::-1] == str_x: return True else: return False 进阶任务：如何在不转为字符串的前提下解决这个问题 在不转为字符串的前提下，我们只要用数字的方法计算出反转后的数字大小进行比较就可以达到目的 代码如下： 1234567891011121314class Solution: def isPalindrome(self, x: int) -&gt; bool: if x &lt; 0 : return False m,n = x,0 while m: n = n*10 + m%10 m = m//10 if x == n: return True else: return False 今天的比较简单，留空看看大型数据库吧= = 我能够允许你逃避过去，不过至少从现在或者明天开始都不要再逃避。 -「无头骑士异闻录」","path":"2019/10/23/leetcode-回文数/","date":"10-23","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://nomalbuthappy.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://nomalbuthappy.github.io/tags/leetcode/"}]},{"title":"212 23事","text":"212 23事这篇博客的内容来自博主波澜不惊的日常，记下来当作回忆 为了保护个人隐私，以下人名全部由字母w，y，z，h代替 该博客将不定期更新，全凭心情 1.dai作家z: 我说啊，不是有一种学习方法叫渗透压学习法吗？ y: 是啊，就是那个睡觉的时候把书放在枕头下，然后由于书里的知识渗透压比大脑大，会不断渗入大脑嘛 z: 对啊，但是你不感觉奇怪吗？这个效应应该发生在液体之间，而书和大脑都是固体，怎么发生这个作用？ y: 分子的无规则运动也可以发生在固体和固体之间啊，像那个金块和铅块 h: 你还没考虑知识可能会沉降，那就是说你脑袋里的知识可能会往书里走 z: 那我早上一觉起来不是发现书的页数变多了？？？ y: 那你不就成了作者了，从你的知识储备来看，会是嘎啦game CG集= = z: 沉啦，那我也是dai作家啦 2. 杀室友晚上放学的时候 h: 今天晚上一定要早睡！ y: 不可能的，每天都这么说，你看哪天早睡了？ h: 如果我超过1点，每晚睡10分钟 y: ？？？ h: 我就杀一个室友 y: = =||| h: = = y: ？？？？？？！！！！！！ 在一顿操作猛如虎以后，凌晨四点半了 y: h，你还记得晚上说过什么吗？ h: = = z: 他说了什么啊 y: 他说每超过一点钟10分钟睡觉 h: 我就杀一个室友 z: 你也太狠了嗷~~ y: 不如随机杀一个，另外两个直接保研 h: 那就杀你吧 y: 不太行，我得套复活甲 z: 现在四点半，算起来要杀21个室友，一个复活甲不太行 y: 现在我们有三个人，每个人把装备栏套满，那就是18条命，艹 z: h，我们可不可以等个复活甲冷却 h: zzzzZZZZ y: = = z: = = w: = = 3. 谁的锅w在看斗罗大陆动画 w: 我发现宁荣荣的那个比柳二龙的还要大 y: 那不就是建模的锅咯 z: 嗯？升调 剑魔又背锅咯？怎么不是剑圣的锅啦 y: ？？？ w: 行吧，那就是剑圣的锅 h: 好，决定了，就是剑姬的锅","path":"2019/10/01/212-23事/","date":"10-01","excerpt":"","tags":[{"name":"日常","slug":"日常","permalink":"https://nomalbuthappy.github.io/tags/%E6%97%A5%E5%B8%B8/"}]}]}